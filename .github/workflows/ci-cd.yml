name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - '.gitignore'
      - '.pre-commit-config.yaml'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/labels.yml'
      - '.github/dependabot.yml'
      - '.github/workflows/**'
  pull_request:
    types: [opened, reopened, labeled]
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - '.gitignore'
      - '.pre-commit-config.yaml'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/labels.yml'
      - '.github/dependabot.yml'
      - '.github/workflows/**'

jobs:
  check-trigger:
    name: Check if CI/CD should run
    runs-on: ubuntu-slim
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
    steps:
      - name: Check trigger conditions
        id: check
        run: |
          # Always run on push to main
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "âœ… Running CI/CD pipeline (push to main)"
            echo "should_run=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # For PRs, only run if ci/ready label is present
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            if [[ "${{ contains(github.event.pull_request.labels.*.name, 'ci/ready') }}" == "true" ]]; then
              echo "âœ… Running CI/CD pipeline (ci/ready label present)"
              echo "should_run=true" >> $GITHUB_OUTPUT
            else
              echo "â­ï¸  Skipping CI/CD pipeline (ci/ready label not present)"
              echo "ðŸ’¡ Add the 'ci/ready' label to trigger full build, scan, and test pipeline"
              echo "should_run=false" >> $GITHUB_OUTPUT
            fi
            exit 0
          fi

          # Fallback: don't run
          echo "should_run=false" >> $GITHUB_OUTPUT

  lint-dockerfile:
    name: Lint Dockerfile
    runs-on: ubuntu-latest
    needs: check-trigger
    if: needs.check-trigger.outputs.should_run == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Check if Dockerfile exists
        id: check_dockerfile
        run: |
          if [ -f Dockerfile ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ Dockerfile not found, skipping hadolint"
          fi

      - name: Run hadolint
        if: steps.check_dockerfile.outputs.exists == 'true'
        uses: hadolint/hadolint-action@v3.3.0
        with:
          dockerfile: Dockerfile
          ignore: DL3008,DL3018
          # DL3008: Pin versions in apt-get install
          # DL3018: Pin versions in apk add

  build:
    name: Build Container
    runs-on: ubuntu-latest
    needs: lint-dockerfile

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Check if Dockerfile exists
        id: check_dockerfile
        run: |
          if [ -f Dockerfile ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ Dockerfile not found, skipping build"
          fi

      - name: Set up Docker Buildx
        if: steps.check_dockerfile.outputs.exists == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Build container
        if: steps.check_dockerfile.outputs.exists == 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          outputs: type=docker,dest=/tmp/mc-server-container.tar
          tags: mc-server-container:test
          cache-from: |
            type=gha,scope=${{ github.ref }}
            type=gha,scope=refs/heads/main
          cache-to: type=gha,mode=max,scope=${{ github.ref }}

      - name: Upload container artifact
        if: steps.check_dockerfile.outputs.exists == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: container-image
          path: /tmp/mc-server-container.tar
          retention-days: 1

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: build
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Download container artifact
        uses: actions/download-artifact@v4
        with:
          name: container-image
          path: /tmp

      - name: Load container image
        run: |
          docker load -i /tmp/mc-server-container.tar
          docker images

      - name: Run Trivy vulnerability scanner (table output)
        uses: aquasecurity/trivy-action@0.33.1
        with:
          image-ref: 'mc-server-container:test'
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM'
          exit-code: '0'  # Don't fail the workflow, just report

      - name: Run Trivy vulnerability scanner (JSON output)
        uses: aquasecurity/trivy-action@0.33.1
        with:
          image-ref: 'mc-server-container:test'
          format: 'json'
          output: 'trivy-results.json'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'  # Don't fail the workflow, just report

      - name: Run Trivy config scanner (Dockerfile)
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: 'config'
          scan-ref: '.'
          format: 'table'
          exit-code: '0'  # Don't fail the workflow, just report

  test-docker:
    name: Test Container with Docker
    runs-on: ubuntu-latest
    needs: security-scan

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Download container artifact
        uses: actions/download-artifact@v4
        with:
          name: container-image
          path: /tmp

      - name: Load container image
        run: |
          docker load -i /tmp/mc-server-container.tar
          docker images

      - name: Get Paper version info
        id: paper_version
        run: |
          echo "ðŸ” Querying Paper API for latest version..."
          USER_AGENT="GitHub Actions for container build (miikka@iki.fi)"

          # Get latest Paper version
          PAPER_VERSION=$(curl -s -H "User-Agent: $USER_AGENT" "https://fill.papermc.io/v3/projects/paper" | \
            jq -r '.versions | to_entries[0] | .value[0]')

          # Get latest build number for that version
          BUILD_NUMBER=$(curl -s -H "User-Agent: $USER_AGENT" "https://fill.papermc.io/v3/projects/paper/versions/${PAPER_VERSION}" | \
            jq -r '.builds[0]')

          echo "version=${PAPER_VERSION}" >> $GITHUB_OUTPUT
          echo "build=${BUILD_NUMBER}" >> $GITHUB_OUTPUT
          echo "ðŸ“‹ Paper ${PAPER_VERSION} build ${BUILD_NUMBER}"

      - name: Cache Paper JAR
        id: cache_paper
        uses: actions/cache@v4
        with:
          path: paper.jar
          key: paper-jar-${{ steps.paper_version.outputs.version }}-${{ steps.paper_version.outputs.build }}

      - name: Download Paper JAR
        if: steps.cache_paper.outputs.cache-hit != 'true'
        run: |
          echo "â¬‡ï¸  Downloading Paper JAR (cache miss)..."
          USER_AGENT="GitHub Actions for container build (miikka@iki.fi)"
          PAPER_VERSION="${{ steps.paper_version.outputs.version }}"
          BUILD_NUMBER="${{ steps.paper_version.outputs.build }}"

          # Get download URL
          DOWNLOAD_URL=$(curl -s -H "User-Agent: $USER_AGENT" "https://fill.papermc.io/v3/projects/paper/versions/${PAPER_VERSION}/builds" | \
            jq -r 'max_by(.id) | .downloads["server:default"].url')

          echo "ðŸ“‹ Downloading Paper ${PAPER_VERSION} build ${BUILD_NUMBER}"

          # Download Paper JAR
          curl -s -o paper.jar "${DOWNLOAD_URL}"

          # Verify download
          if [ ! -f paper.jar ]; then
            echo "âŒ Failed to download Paper JAR"
            exit 1
          fi

          JAR_SIZE=$(stat -c%s paper.jar 2>/dev/null || stat -f%z paper.jar)
          echo "âœ… Downloaded Paper JAR (${JAR_SIZE} bytes)"

      - name: Prepare test data
        run: |
          echo "ðŸ“¦ Preparing test data directory"
          mkdir -p test-data

          # Accept EULA
          echo "eula=true" > test-data/eula.txt
          echo "âœ… Created eula.txt"

          # Copy Paper JAR from cache or download
          if [ "${{ steps.cache_paper.outputs.cache-hit }}" == "true" ]; then
            echo "ðŸ“¦ Using cached Paper JAR"
          fi
          cp paper.jar test-data/paper.jar

          JAR_SIZE=$(stat -c%s test-data/paper.jar 2>/dev/null || stat -f%z test-data/paper.jar)
          echo "âœ… Paper JAR ready (${JAR_SIZE} bytes)"

          # Change ownership to minecraft user (UID 25565)
          # This allows the container's minecraft user to write to /data
          echo "ðŸ”§ Setting permissions for minecraft user"
          sudo chown -R 25565:25565 test-data
          echo "âœ… Permissions set"

      - name: Run integration tests
        run: |
          echo "ðŸ§ª Starting integration test with real Paper server"

          # Start container with actual data
          docker run -d --name mc-test \
            -v $(pwd)/test-data:/data \
            -e MEMORY=2G \
            mc-server-container:test

          echo "â³ Waiting for Paper server to start (this may take 30-60 seconds)..."

          # Wait up to 90 seconds for server to start
          MAX_WAIT=90
          ELAPSED=0
          SERVER_STARTED=false

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            if docker logs mc-test 2>&1 | grep -q "Done (.*s)! For help, type \"help\""; then
              SERVER_STARTED=true
              echo "âœ… Server started successfully after ${ELAPSED}s"
              break
            fi

            # Check if container is still running
            if [ "$(docker inspect -f '{{.State.Running}}' mc-test)" != "true" ]; then
              echo "âŒ Container stopped unexpectedly"
              echo "ðŸ“‹ Container logs:"
              docker logs mc-test
              exit 1
            fi

            sleep 5
            ELAPSED=$((ELAPSED + 5))
            echo "  ... waiting (${ELAPSED}s / ${MAX_WAIT}s)"
          done

          if [ "$SERVER_STARTED" != "true" ]; then
            echo "âŒ Server failed to start within ${MAX_WAIT} seconds"
            echo "ðŸ“‹ Container logs:"
            docker logs mc-test
            exit 1
          fi

          echo ""
          echo "ðŸ“‹ Server startup logs:"
          docker logs mc-test | tail -20

          echo ""
          echo "âœ… Integration test passed - Paper server started successfully"

          # Cleanup
          echo ""
          echo "ðŸ§¹ Cleaning up test container"
          docker stop mc-test
          docker rm mc-test
          sudo rm -rf test-data

  test-podman:
    name: Test Container with Podman (OCI Compliance)
    runs-on: ubuntu-latest
    needs: security-scan

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Download container artifact
        uses: actions/download-artifact@v4
        with:
          name: container-image
          path: /tmp

      - name: Install Podman
        run: |
          echo "ðŸ“¦ Installing Podman"
          sudo apt-get update
          sudo apt-get install -y podman
          podman --version

      - name: Load image into Podman
        run: |
          echo "ðŸ“¥ Loading Docker image into Podman (rootful storage)"
          # Load with sudo to place image in rootful storage, since we run with sudo later
          sudo podman load -i /tmp/mc-server-container.tar
          sudo podman images

      - name: Get Paper version info for Podman test
        id: paper_version_podman
        run: |
          echo "ðŸ” Querying Paper API for latest version..."
          USER_AGENT="GitHub Actions for container build (miikka@iki.fi)"

          # Get latest Paper version
          PAPER_VERSION=$(curl -s -H "User-Agent: $USER_AGENT" "https://fill.papermc.io/v3/projects/paper" | \
            jq -r '.versions | to_entries[0] | .value[0]')

          # Get latest build number for that version
          BUILD_NUMBER=$(curl -s -H "User-Agent: $USER_AGENT" "https://fill.papermc.io/v3/projects/paper/versions/${PAPER_VERSION}" | \
            jq -r '.builds[0]')

          echo "version=${PAPER_VERSION}" >> $GITHUB_OUTPUT
          echo "build=${BUILD_NUMBER}" >> $GITHUB_OUTPUT
          echo "ðŸ“‹ Paper ${PAPER_VERSION} build ${BUILD_NUMBER}"

      - name: Cache Paper JAR for Podman test
        id: cache_paper_podman
        uses: actions/cache@v4
        with:
          path: paper-podman.jar
          key: paper-jar-${{ steps.paper_version_podman.outputs.version }}-${{ steps.paper_version_podman.outputs.build }}

      - name: Download Paper JAR for Podman test
        if: steps.cache_paper_podman.outputs.cache-hit != 'true'
        run: |
          echo "â¬‡ï¸  Downloading Paper JAR (cache miss)..."
          USER_AGENT="GitHub Actions for container build (miikka@iki.fi)"
          PAPER_VERSION="${{ steps.paper_version_podman.outputs.version }}"
          BUILD_NUMBER="${{ steps.paper_version_podman.outputs.build }}"

          # Get download URL
          DOWNLOAD_URL=$(curl -s -H "User-Agent: $USER_AGENT" "https://fill.papermc.io/v3/projects/paper/versions/${PAPER_VERSION}/builds" | \
            jq -r 'max_by(.id) | .downloads["server:default"].url')

          echo "ðŸ“‹ Downloading Paper ${PAPER_VERSION} build ${BUILD_NUMBER}"

          # Download Paper JAR
          curl -s -o paper-podman.jar "${DOWNLOAD_URL}"

          # Verify download
          if [ ! -f paper-podman.jar ]; then
            echo "âŒ Failed to download Paper JAR"
            exit 1
          fi

          JAR_SIZE=$(stat -c%s paper-podman.jar 2>/dev/null || stat -f%z paper-podman.jar)
          echo "âœ… Downloaded Paper JAR (${JAR_SIZE} bytes)"

      - name: Prepare test data for Podman
        run: |
          echo "ðŸ“¦ Preparing test data directory for Podman"
          mkdir -p test-data-podman

          # Accept EULA
          echo "eula=true" > test-data-podman/eula.txt
          echo "âœ… Created eula.txt"

          # Copy Paper JAR from cache or download
          if [ "${{ steps.cache_paper_podman.outputs.cache-hit }}" == "true" ]; then
            echo "ðŸ“¦ Using cached Paper JAR"
          fi
          cp paper-podman.jar test-data-podman/paper.jar

          JAR_SIZE=$(stat -c%s test-data-podman/paper.jar 2>/dev/null || stat -f%z test-data-podman/paper.jar)
          echo "âœ… Paper JAR ready (${JAR_SIZE} bytes)"

          # Change ownership to minecraft user (UID 25565)
          # This allows the container's minecraft user to write to /data
          echo "ðŸ”§ Setting permissions for minecraft user"
          sudo chown -R 25565:25565 test-data-podman
          echo "âœ… Permissions set"

      - name: Run Podman integration tests
        run: |
          echo "ðŸ§ª Starting Podman integration test (OCI compliance verification)"

          # Start container with Podman in rootful mode (using sudo)
          # Rootful mode ensures consistent UID mapping with Docker (container UID 25565 = host UID 25565)
          # Note: After podman load, the image is tagged as mc-server-container:test (without localhost prefix)
          sudo podman run -d --name mc-test-podman \
            -v $(pwd)/test-data-podman:/data:Z \
            -e EULA=TRUE \
            -e MEMORY=2G \
            mc-server-container:test

          echo "â³ Waiting for Paper server to start with Podman (this may take 30-60 seconds)..."

          # Wait up to 90 seconds for server to start
          MAX_WAIT=90
          ELAPSED=0
          SERVER_STARTED=false

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            if sudo podman logs mc-test-podman 2>&1 | grep -q "Done (.*s)! For help, type \"help\""; then
              SERVER_STARTED=true
              echo "âœ… Server started successfully with Podman after ${ELAPSED}s"
              break
            fi

            # Check if container is still running
            if [ "$(sudo podman inspect -f '{{.State.Running}}' mc-test-podman)" != "true" ]; then
              echo "âŒ Container stopped unexpectedly"
              echo "ðŸ“‹ Container logs:"
              sudo podman logs mc-test-podman
              exit 1
            fi

            sleep 5
            ELAPSED=$((ELAPSED + 5))
            echo "  ... waiting (${ELAPSED}s / ${MAX_WAIT}s)"
          done

          if [ "$SERVER_STARTED" != "true" ]; then
            echo "âŒ Server failed to start within ${MAX_WAIT} seconds"
            echo "ðŸ“‹ Container logs:"
            sudo podman logs mc-test-podman
            exit 1
          fi

          echo ""
          echo "ðŸ“‹ Server startup logs:"
          sudo podman logs mc-test-podman | tail -20

          echo ""
          echo "âœ… Podman integration test passed - OCI compliance verified!"

          # Cleanup
          echo ""
          echo "ðŸ§¹ Cleaning up Podman test container"
          sudo podman stop mc-test-podman
          sudo podman rm mc-test-podman
          sudo rm -rf test-data-podman

  check-release:
    name: Check Release Labels
    runs-on: ubuntu-slim
    # Only run on main branch pushes, after tests pass
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    needs: [test-docker, test-podman]
    permissions:
      contents: read
      pull-requests: read
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      version_bump: ${{ steps.check.outputs.version_bump }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Check for release labels in recent commit
        id: check
        uses: actions/github-script@v8
        with:
          script: |
            const commit = context.sha;

            // Get PRs associated with this commit
            const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: commit
            });

            if (prs.data.length === 0) {
              console.log('No PR associated with this commit');
              core.setOutput('should_release', 'false');
              return;
            }

            const pr = prs.data[0];
            const labels = pr.labels.map(l => l.name);

            console.log('PR labels:', labels);

            if (labels.includes('release:major')) {
              core.setOutput('should_release', 'true');
              core.setOutput('version_bump', 'major');
            } else if (labels.includes('release:minor')) {
              core.setOutput('should_release', 'true');
              core.setOutput('version_bump', 'minor');
            } else if (labels.includes('release:patch')) {
              core.setOutput('should_release', 'true');
              core.setOutput('version_bump', 'patch');
            } else {
              console.log('No release label found');
              core.setOutput('should_release', 'false');
            }

  release:
    name: Release
    runs-on: ubuntu-latest
    needs: check-release
    if: needs.check-release.outputs.should_release == 'true'
    permissions:
      contents: write
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Download container artifact
        uses: actions/download-artifact@v4
        with:
          name: container-image
          path: /tmp

      - name: Load container image
        run: |
          docker load -i /tmp/mc-server-container.tar
          docker images

      - name: Get latest tag
        id: get_tag
        run: |
          # Get latest tag or default to 0.0.0
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

          # Remove 'v' prefix for version calculation
          VERSION=${LATEST_TAG#v}
          echo "current_version=$VERSION" >> $GITHUB_OUTPUT

      - name: Calculate new version
        id: new_version
        run: |
          VERSION="${{ steps.get_tag.outputs.current_version }}"
          BUMP="${{ needs.check-release.outputs.version_bump }}"

          IFS='.' read -r major minor patch <<< "$VERSION"

          if [ "$BUMP" = "major" ]; then
            major=$((major + 1))
            minor=0
            patch=0
          elif [ "$BUMP" = "minor" ]; then
            minor=$((minor + 1))
            patch=0
          elif [ "$BUMP" = "patch" ]; then
            patch=$((patch + 1))
          fi

          NEW_VERSION="$major.$minor.$patch"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Tag and push container
        run: |
          VERSION="${{ steps.new_version.outputs.version }}"

          # Tag the tested image with version tags
          docker tag mc-server-container:test ghcr.io/${{ github.repository }}:latest
          docker tag mc-server-container:test ghcr.io/${{ github.repository }}:${VERSION}

          # Push both tags
          docker push ghcr.io/${{ github.repository }}:latest
          docker push ghcr.io/${{ github.repository }}:${VERSION}

      - name: Create GitHub Release
        uses: actions/github-script@v8
        with:
          script: |
            const tag = '${{ steps.new_version.outputs.tag }}';
            const version = '${{ steps.new_version.outputs.version }}';

            await github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `refs/tags/${tag}`,
              sha: context.sha
            });

            await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tag,
              name: `Release ${version}`,
              body: `## Release ${version}\n\nDocker image: \`ghcr.io/${{ github.repository }}:${version}\`\n\nPull with:\n\`\`\`bash\ndocker pull ghcr.io/${{ github.repository }}:${version}\n\`\`\``,
              draft: false,
              prerelease: false
            });
