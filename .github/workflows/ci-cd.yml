name: CI/CD Pipeline

on:
  push:
    branches: [main]
    paths-ignore:
      - '**.md'
      - '.gitignore'
      - '.pre-commit-config.yaml'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/dependabot.yml'
  pull_request:
    types: [opened, reopened, synchronize, labeled]
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  packages: write
  pull-requests: read
  issues: write

jobs:
  check-trigger:
    name: Check CI/CD Trigger
    runs-on: ubuntu-slim
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
    steps:
      - name: Check trigger conditions
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "‚úÖ Running CI/CD (push to main)"
            echo "should_run=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            if [[ "${{ contains(github.event.pull_request.labels.*.name, 'ci/ready') }}" == "true" ]]; then
              echo "‚úÖ Running CI/CD (ci/ready label)"
              echo "should_run=true" >> "$GITHUB_OUTPUT"
            else
              echo "‚è≠Ô∏è  Skipping CI/CD (add ci/ready label to run)"
              echo "should_run=false" >> "$GITHUB_OUTPUT"
            fi
            exit 0
          fi

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "‚úÖ Running CI/CD (manual trigger)"
            echo "should_run=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "should_run=false" >> "$GITHUB_OUTPUT"

  lint:
    name: Lint and Validate
    runs-on: ubuntu-latest
    needs: check-trigger
    if: needs.check-trigger.outputs.should_run == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Run hadolint
        uses: hadolint/hadolint-action@v3.3.0
        with:
          dockerfile: Dockerfile
          ignore: DL3008,DL3018

      - name: Run pre-commit hooks
        uses: pre-commit/action@v3.0.1
        env:
          SKIP: no-commit-to-branch
        continue-on-error: true

      - name: Shellcheck
        run: |
          if command -v shellcheck >/dev/null 2>&1; then
            find . -name "*.sh" -o -name "*.bash" | while read -r file; do
              echo "Checking $file"
              dir=$(dirname "$file")
              (cd "$dir" && shellcheck --external-sources "$(basename "$file")") || exit 1
            done
          else
            echo "Shellcheck not available, skipping"
          fi

  build-container:
    name: Build Container Image
    runs-on: ubuntu-latest
    needs: lint

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/amd64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build container for testing
        uses: docker/build-push-action@v6
        with:
          context: .
          outputs: type=docker,dest=/tmp/mc-server-container.tar
          tags: mc-server-container:test
          platforms: linux/amd64
          cache-from: |
            type=gha,scope=${{ github.ref }}
            type=gha,scope=refs/heads/main
          cache-to: type=gha,mode=max,scope=${{ github.ref }}

      - name: Upload container artifact
        uses: actions/upload-artifact@v5
        with:
          name: container-image
          path: /tmp/mc-server-container.tar
          retention-days: 1

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: build-container
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Download container artifact
        uses: actions/download-artifact@v6
        with:
          name: container-image
          path: /tmp

      - name: Load container image
        run: |
          docker load -i /tmp/mc-server-container.tar
          docker images

      - name: Run Trivy vulnerability scanner (table output)
        uses: aquasecurity/trivy-action@0.33.1
        with:
          image-ref: 'mc-server-container:test'
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM'
          exit-code: '0'

      - name: Run Trivy vulnerability scanner (JSON output)
        uses: aquasecurity/trivy-action@0.33.1
        with:
          image-ref: 'mc-server-container:test'
          format: 'json'
          output: 'trivy-results.json'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'

      - name: Run Trivy config scanner (Dockerfile)
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: 'config'
          scan-ref: '.'
          format: 'table'
          exit-code: '0'

  test-docker:
    name: Test Container with Docker
    runs-on: ubuntu-latest
    needs: security-scan

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Download container artifact
        uses: actions/download-artifact@v6
        with:
          name: container-image
          path: /tmp

      - name: Load container image
        run: |
          docker load -i /tmp/mc-server-container.tar
          docker images

      - name: Get Paper version info
        id: paper_version
        run: |
          echo "üîç Querying Paper API for latest version..."
          USER_AGENT="GitHub Actions for container build (miikka@iki.fi)"

          # Get latest Paper version
          PAPER_API_URL="https://fill.papermc.io/v3/projects/paper"
          PAPER_VERSION=$(curl -s -H "User-Agent: $USER_AGENT" "${PAPER_API_URL}" | \
            jq -r '.versions | to_entries[0] | .value[0]')

          # Get latest build number for that version
          PAPER_VERSION_API_URL="${PAPER_API_URL}/versions/${PAPER_VERSION}"
          BUILD_NUMBER=$(curl -s -H "User-Agent: $USER_AGENT" "${PAPER_VERSION_API_URL}" | \
            jq -r '.builds[0]')

          echo "version=${PAPER_VERSION}" >> "$GITHUB_OUTPUT"
          echo "build=${BUILD_NUMBER}" >> "$GITHUB_OUTPUT"
          echo "üìã Paper ${PAPER_VERSION} build ${BUILD_NUMBER}"

      - name: Cache Paper JAR
        id: cache_paper
        uses: actions/cache@v4
        with:
          path: paper.jar
          key: paper-jar-${{ steps.paper_version.outputs.version }}-${{ steps.paper_version.outputs.build }}

      - name: Download Paper JAR
        if: steps.cache_paper.outputs.cache-hit != 'true'
        run: |
          echo "‚¨áÔ∏è  Downloading Paper JAR (cache miss)..."
          USER_AGENT="GitHub Actions for container build (miikka@iki.fi)"
          PAPER_VERSION="${{ steps.paper_version.outputs.version }}"
          BUILD_NUMBER="${{ steps.paper_version.outputs.build }}"

          # Get download URL
          PAPER_BUILDS_API="https://fill.papermc.io/v3/projects/paper/versions/${PAPER_VERSION}/builds"
          DOWNLOAD_URL=$(curl -s -H "User-Agent: $USER_AGENT" "${PAPER_BUILDS_API}" | \
            jq -r 'max_by(.id) | .downloads["server:default"].url')

          echo "üìã Downloading Paper ${PAPER_VERSION} build ${BUILD_NUMBER}"

          # Download Paper JAR
          curl -s -o paper.jar "${DOWNLOAD_URL}"

          # Verify download
          if [[ ! -f paper.jar ]]; then
            echo "‚ùå Failed to download Paper JAR"
            exit 1
          fi

          JAR_SIZE=$(stat -c%s paper.jar 2>/dev/null || stat -f%z paper.jar)
          echo "‚úÖ Downloaded Paper JAR (${JAR_SIZE} bytes)"

      - name: Prepare test data
        run: |
          echo "üì¶ Preparing test data directory"
          mkdir -p test-data

          # Accept EULA
          echo "eula=true" > test-data/eula.txt
          echo "‚úÖ Created eula.txt"

          # Copy Paper JAR from cache or download
          if [[ "${{ steps.cache_paper.outputs.cache-hit }}" == "true" ]]; then
            echo "üì¶ Using cached Paper JAR"
          fi
          cp paper.jar test-data/paper.jar

          JAR_SIZE=$(stat -c%s test-data/paper.jar 2>/dev/null || stat -f%z test-data/paper.jar)
          echo "‚úÖ Paper JAR ready (${JAR_SIZE} bytes)"

          # Change ownership to minecraft user (UID 25565)
          echo "üîß Setting permissions for minecraft user"
          sudo chown -R 25565:25565 test-data
          echo "‚úÖ Permissions set"

      - name: Run integration tests
        run: |
          echo "üß™ Starting integration test with real Paper server"

          # Start container with actual data
          docker run -d --name mc-test \
            -v "$(pwd)/test-data:/data" \
            -e MEMORY=2G \
            mc-server-container:test

          echo "‚è≥ Waiting for Paper server to start (this may take 30-60 seconds)..."

          # Wait up to 90 seconds for server to start
          MAX_WAIT=90
          ELAPSED=0
          SERVER_STARTED=false

          while (( ELAPSED < MAX_WAIT )); do
            if docker logs mc-test 2>&1 | grep -q "Done (.*s)! For help, type \"help\""; then
              SERVER_STARTED=true
              echo "‚úÖ Server started successfully after ${ELAPSED}s"
              break
            fi

            # Check if container is still running
            if [[ "$(docker inspect -f '{{.State.Running}}' mc-test)" != "true" ]]; then
              echo "‚ùå Container stopped unexpectedly"
              echo "üìã Container logs:"
              docker logs mc-test
              exit 1
            fi

            sleep 5
            ELAPSED=$((ELAPSED + 5))
            echo "  ... waiting (${ELAPSED}s / ${MAX_WAIT}s)"
          done

          if [[ "$SERVER_STARTED" != "true" ]]; then
            echo "‚ùå Server failed to start within ${MAX_WAIT} seconds"
            echo "üìã Container logs:"
            docker logs mc-test
            exit 1
          fi

          echo ""
          echo "üìã Server startup logs:"
          docker logs mc-test | tail -20

          echo ""
          echo "‚úÖ Integration test passed - Paper server started successfully"

          # Cleanup
          echo ""
          echo "üßπ Cleaning up test container"
          docker stop mc-test
          docker rm mc-test
          sudo rm -rf test-data

  test-podman:
    name: Test Container with Podman (OCI Compliance)
    runs-on: ubuntu-latest
    needs: security-scan

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Download container artifact
        uses: actions/download-artifact@v6
        with:
          name: container-image
          path: /tmp

      - name: Install Podman
        run: |
          echo "üì¶ Installing Podman"
          sudo apt-get update
          sudo apt-get install -y podman
          podman --version

      - name: Load image into Podman
        run: |
          echo "üì• Loading Docker image into Podman (rootful storage)"
          sudo podman load -i /tmp/mc-server-container.tar
          sudo podman images

      - name: Get Paper version info for Podman test
        id: paper_version_podman
        run: |
          echo "üîç Querying Paper API for latest version..."
          USER_AGENT="GitHub Actions for container build (miikka@iki.fi)"

          # Get latest Paper version
          PAPER_API_URL="https://fill.papermc.io/v3/projects/paper"
          PAPER_VERSION=$(curl -s -H "User-Agent: $USER_AGENT" "${PAPER_API_URL}" | \
            jq -r '.versions | to_entries[0] | .value[0]')

          # Get latest build number for that version
          PAPER_VERSION_API_URL="${PAPER_API_URL}/versions/${PAPER_VERSION}"
          BUILD_NUMBER=$(curl -s -H "User-Agent: $USER_AGENT" "${PAPER_VERSION_API_URL}" | \
            jq -r '.builds[0]')

          echo "version=${PAPER_VERSION}" >> "$GITHUB_OUTPUT"
          echo "build=${BUILD_NUMBER}" >> "$GITHUB_OUTPUT"
          echo "üìã Paper ${PAPER_VERSION} build ${BUILD_NUMBER}"

      - name: Cache Paper JAR for Podman test
        id: cache_paper_podman
        uses: actions/cache@v4
        with:
          path: paper.jar
          key: |
            paper-jar-${{ steps.paper_version_podman.outputs.version }}-${{ steps.paper_version_podman.outputs.build }}

      - name: Download Paper JAR for Podman test
        if: steps.cache_paper_podman.outputs.cache-hit != 'true'
        run: |
          echo "‚¨áÔ∏è  Downloading Paper JAR (cache miss)..."
          USER_AGENT="GitHub Actions for container build (miikka@iki.fi)"
          PAPER_VERSION="${{ steps.paper_version_podman.outputs.version }}"
          BUILD_NUMBER="${{ steps.paper_version_podman.outputs.build }}"

          # Get download URL
          PAPER_BUILDS_API="https://fill.papermc.io/v3/projects/paper/versions/${PAPER_VERSION}/builds"
          DOWNLOAD_URL=$(curl -s -H "User-Agent: $USER_AGENT" "${PAPER_BUILDS_API}" | \
            jq -r 'max_by(.id) | .downloads["server:default"].url')

          echo "üìã Downloading Paper ${PAPER_VERSION} build ${BUILD_NUMBER}"

          # Download Paper JAR
          curl -s -o paper.jar "${DOWNLOAD_URL}"

          # Verify download
          if [[ ! -f paper.jar ]]; then
            echo "‚ùå Failed to download Paper JAR"
            exit 1
          fi

          JAR_SIZE=$(stat -c%s paper.jar 2>/dev/null || stat -f%z paper.jar)
          echo "‚úÖ Downloaded Paper JAR (${JAR_SIZE} bytes)"

      - name: Prepare test data for Podman
        run: |
          echo "üì¶ Preparing test data directory for Podman"
          mkdir -p test-data-podman

          # Accept EULA
          echo "eula=true" > test-data-podman/eula.txt
          echo "‚úÖ Created eula.txt"

          # Copy Paper JAR from cache or download
          if [[ "${{ steps.cache_paper_podman.outputs.cache-hit }}" == "true" ]]; then
            echo "üì¶ Using cached Paper JAR"
          fi
          cp paper.jar test-data-podman/paper.jar

          JAR_SIZE=$(stat -c%s test-data-podman/paper.jar 2>/dev/null || stat -f%z test-data-podman/paper.jar)
          echo "‚úÖ Paper JAR ready (${JAR_SIZE} bytes)"

          # Change ownership to minecraft user (UID 25565)
          echo "üîß Setting permissions for minecraft user"
          sudo chown -R 25565:25565 test-data-podman
          echo "‚úÖ Permissions set"

      - name: Run Podman integration tests
        run: |
          echo "üß™ Starting Podman integration test (OCI compliance verification)"

          # Start container with Podman in rootful mode
          sudo podman run -d --name mc-test-podman \
            -v "$(pwd)/test-data-podman:/data:Z" \
            -e MEMORY=2G \
            mc-server-container:test

          echo "‚è≥ Waiting for Paper server to start with Podman (this may take 30-60 seconds)..."

          # Wait up to 90 seconds for server to start
          MAX_WAIT=90
          ELAPSED=0
          SERVER_STARTED=false

          while (( ELAPSED < MAX_WAIT )); do
            if sudo podman logs mc-test-podman 2>&1 | grep -q "Done (.*s)! For help, type \"help\""; then
              SERVER_STARTED=true
              echo "‚úÖ Server started successfully with Podman after ${ELAPSED}s"
              break
            fi

            # Check if container is still running
            if [[ "$(sudo podman inspect -f '{{.State.Running}}' mc-test-podman)" != "true" ]]; then
              echo "‚ùå Container stopped unexpectedly"
              echo "üìã Container logs:"
              sudo podman logs mc-test-podman
              exit 1
            fi

            sleep 5
            ELAPSED=$((ELAPSED + 5))
            echo "  ... waiting (${ELAPSED}s / ${MAX_WAIT}s)"
          done

          if [[ "$SERVER_STARTED" != "true" ]]; then
            echo "‚ùå Server failed to start within ${MAX_WAIT} seconds"
            echo "üìã Container logs:"
            sudo podman logs mc-test-podman
            exit 1
          fi

          echo ""
          echo "üìã Server startup logs:"
          sudo podman logs mc-test-podman | tail -20

          echo ""
          echo "‚úÖ Podman integration test passed - OCI compliance verified!"

          # Cleanup
          echo ""
          echo "üßπ Cleaning up Podman test container"
          sudo podman stop mc-test-podman
          sudo podman rm mc-test-podman
          sudo rm -rf test-data-podman

  build-tarball:
    name: Build Tarball Artifacts
    runs-on: ubuntu-slim
    needs: [test-docker, test-podman]
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' && startsWith(github.ref, 'refs/tags/'))

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Get repository info
        id: repo_info
        run: |
          REPO_NAME="${{ github.event.repository.name }}"
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:7}"

          # Get git version (tag or describe)
          GIT_VERSION=$(git describe --tags --always 2>/dev/null || echo "dev-$SHORT_SHA")

          # Get deployment date (ISO 8601)
          DEPLOY_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          {
            echo "repo_name=$REPO_NAME"
            echo "short_sha=$SHORT_SHA"
            echo "git_version=$GIT_VERSION"
            echo "deploy_date=$DEPLOY_DATE"
          } >> "$GITHUB_OUTPUT"

          echo "üì¶ Repository: $REPO_NAME"
          echo "üì¶ Version: $GIT_VERSION"
          echo "üì¶ Deploy date: $DEPLOY_DATE"

      - name: Replace version placeholders
        run: |
          GIT_VERSION="${{ steps.repo_info.outputs.git_version }}"
          DEPLOY_DATE="${{ steps.repo_info.outputs.deploy_date }}"

          echo "üîÑ Replacing version placeholders..."

          # Find and replace @GIT_VERSION@ placeholder
          if grep -r "@GIT_VERSION@" . --exclude-dir=.git >/dev/null 2>&1; then
            find . -type f -not -path "./.git/*" -exec grep -l "@GIT_VERSION@" {} \; | while read -r file; do
              sed -i "s/@GIT_VERSION@/$GIT_VERSION/g" "$file"
              echo "  ‚úì Updated $file (version)"
            done
          fi

          # Find and replace @DEPLOY_DATE@ placeholder
          if grep -r "@DEPLOY_DATE@" . --exclude-dir=.git >/dev/null 2>&1; then
            find . -type f -not -path "./.git/*" -exec grep -l "@DEPLOY_DATE@" {} \; | while read -r file; do
              sed -i "s/@DEPLOY_DATE@/$DEPLOY_DATE/g" "$file"
              echo "  ‚úì Updated $file (date)"
            done
          fi

          echo "‚úÖ Version placeholder replacement complete"

      - name: Create tarball
        run: |
          REPO_NAME="${{ steps.repo_info.outputs.repo_name }}"
          GIT_VERSION="${{ steps.repo_info.outputs.git_version }}"
          TARBALL="${REPO_NAME}-${GIT_VERSION}.tar.gz"

          echo "üì¶ Creating tarball: $TARBALL"

          # Generic structure: tar everything excluding CI/dev files
          echo "  üìÅ Structure: generic (excluding .git, .github, etc.)"
          tar -czf "$TARBALL" \
            --exclude='.git' \
            --exclude='.github' \
            --exclude='*.tar.gz' \
            --exclude='.pre-commit-config.yaml' \
            --exclude='__pycache__' \
            --exclude='*.pyc' \
            --exclude='.ruff_cache' \
            --exclude='node_modules' \
            --exclude='.pytest_cache' \
            . || true

          TAR_SIZE=$(stat -c%s "$TARBALL" 2>/dev/null || stat -f%z "$TARBALL")
          echo "‚úÖ Created $TARBALL ($TAR_SIZE bytes)"
          echo "üìã Version: $GIT_VERSION"

          echo "tarball=$TARBALL" >> "$GITHUB_ENV"

      - name: Upload tarball artifact
        uses: actions/upload-artifact@v5
        with:
          name: ${{ steps.repo_info.outputs.repo_name }}-tarball
          path: "*.tar.gz"
          retention-days: 90

  check-release:
    name: Check Release Labels
    runs-on: ubuntu-slim
    needs: build-tarball
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' && startsWith(github.ref, 'refs/tags/'))
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      version_bump: ${{ steps.check.outputs.version_bump }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Check for release labels
        id: check
        uses: actions/github-script@v8
        with:
          script: |
            // If triggered by workflow_dispatch on a tag, always create release
            if (context.eventName === 'workflow_dispatch' && context.ref.startsWith('refs/tags/')) {
              console.log('üöÄ Workflow dispatch on tag - creating release');
              core.setOutput('should_release', 'true');
              // Version bump doesn't matter since tag already exists
              core.setOutput('version_bump', 'none');
              return;
            }

            const commit = context.sha;

            // Get PRs associated with this commit
            const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: commit
            });

            if (prs.data.length === 0) {
              console.log('‚ÑπÔ∏è  No PR associated with this commit');
              core.setOutput('should_release', 'false');
              return;
            }

            const pr = prs.data[0];
            const labels = pr.labels.map(l => l.name);

            console.log('üìã PR labels:', labels);

            if (labels.includes('release:major')) {
              console.log('üöÄ Major release detected');
              core.setOutput('should_release', 'true');
              core.setOutput('version_bump', 'major');
            } else if (labels.includes('release:minor')) {
              console.log('üöÄ Minor release detected');
              core.setOutput('should_release', 'true');
              core.setOutput('version_bump', 'minor');
            } else if (labels.includes('release:patch')) {
              console.log('üöÄ Patch release detected');
              core.setOutput('should_release', 'true');
              core.setOutput('version_bump', 'patch');
            } else {
              console.log('‚ÑπÔ∏è  No release label found (release:patch/minor/major)');
              core.setOutput('should_release', 'false');
            }

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: check-release
    if: needs.check-release.outputs.should_release == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Get version
        id: version
        run: |
          # If triggered by workflow_dispatch on a tag, use that tag
          REF="${{ github.ref }}"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${REF}" == refs/tags/* ]]; then
            NEW_VERSION="${REF#refs/tags/}"
            echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
            echo "üè∑Ô∏è  Using existing tag: $NEW_VERSION"
            exit 0
          fi

          # Get current version from git tags
          CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          CURRENT_VERSION=${CURRENT_VERSION#v}

          # Parse version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          # Increment based on bump type
          BUMP_TYPE="${{ needs.check-release.outputs.version_bump }}"
          if [[ "$BUMP_TYPE" == "major" ]]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [[ "$BUMP_TYPE" == "minor" ]]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi

          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "üè∑Ô∏è  New version: $NEW_VERSION (was: v$CURRENT_VERSION)"

      - name: Download tarball artifact
        uses: actions/download-artifact@v6
        with:
          name: ${{ github.event.repository.name }}-tarball

      - name: Download container artifact
        uses: actions/download-artifact@v6
        with:
          name: container-image
          path: /tmp

      - name: Load container image
        run: |
          docker load -i /tmp/mc-server-container.tar
          docker images

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Tag and push container images
        run: |
          VERSION="${{ steps.version.outputs.new_version }}"
          REPO_OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.event.repository.name }}"
          IMAGE_BASE="ghcr.io/${REPO_OWNER}/${REPO_NAME}"

          # Tag the tested image
          docker tag mc-server-container:test "${IMAGE_BASE}:${VERSION}"
          docker tag mc-server-container:test "${IMAGE_BASE}:latest"

          # Push both tags
          docker push "${IMAGE_BASE}:${VERSION}"
          docker push "${IMAGE_BASE}:latest"

          echo "‚úÖ Container images pushed to ghcr.io"

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.new_version }}
          name: Release ${{ steps.version.outputs.new_version }}
          draft: false
          prerelease: false
          generate_release_notes: true
          files: |
            *.tar.gz
          body: |
            ## Container Image

            ```bash
            docker pull ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{
              steps.version.outputs.new_version
            }}
            ```

            Platform: linux/amd64

      - name: Trigger webhook deployment
        env:
          WEBHOOK_SECRET: ${{ secrets.WEBHOOK_SECRET }}
        run: |
          DEPLOY_SERVERS="${{ vars.DEPLOY_SERVERS }}"
          if [[ -z "$WEBHOOK_SECRET" || -z "$DEPLOY_SERVERS" ]]; then
            echo "‚è≠Ô∏è  Skipping webhook deployment (WEBHOOK_SECRET or DEPLOY_SERVERS not configured)"
            exit 0
          fi

          VERSION="${{ steps.version.outputs.new_version }}"
          REPO="${{ github.repository }}"

          echo "üîî Triggering webhook deployment..."

          # Create webhook payload
          PAYLOAD=$(cat <<EOF
          {
            "action": "deploy-${{ github.event.repository.name }}",
            "version": "$VERSION",
            "repository": "$REPO",
            "tag_name": "$VERSION"
          }
          EOF
          )

          # Calculate HMAC signature
          SIGNATURE=$(printf '%s' "$PAYLOAD" | openssl dgst -sha256 -hmac "$WEBHOOK_SECRET" | sed 's/^.* //')

          # Send webhook to each server
          FAILED_SERVERS=""
          SUCCESS_COUNT=0
          TOTAL_SERVERS=0

          for server in $DEPLOY_SERVERS; do
            ((TOTAL_SERVERS++)) || true
            echo "üì° Sending webhook to $server..."

            RESPONSE=$(curl -L -s -w "\n%{http_code}" -X POST \
              -H "Content-Type: application/json" \
              -H "X-Hub-Signature-256: sha256=$SIGNATURE" \
              --data "$PAYLOAD" \
              "https://$server/hooks/deploy-${{ github.event.repository.name }}" 2>&1 || echo "000")

            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | head -n-1)

            if [[ "$HTTP_CODE" = "200" ]]; then
              echo "  ‚úÖ Webhook delivered to $server"
              ((SUCCESS_COUNT++)) || true
            else
              echo "  ‚ùå Webhook to $server FAILED with HTTP $HTTP_CODE"
              echo "  Response: $BODY"
              FAILED_SERVERS="$FAILED_SERVERS $server"
            fi
          done

          echo ""
          echo "üìä Webhook Deployment Summary:"
          echo "   Total servers: $TOTAL_SERVERS"
          echo "   Successful: $SUCCESS_COUNT"
          echo "   Failed: $((TOTAL_SERVERS - SUCCESS_COUNT))"

          if [[ -n "$FAILED_SERVERS" ]]; then
            echo ""
            echo "‚ùå Webhook deployment FAILED for:$FAILED_SERVERS"
            echo ""
            echo "Troubleshooting:"
            echo "  - Check nginx configuration and IP allowlist on failed servers"
            echo "  - Verify webhook daemon is running: rc-service webhook status"
            echo "  - Check webhook logs: tail -f /var/log/webhook.log"
            echo "  - Verify HMAC secret matches between GitHub and /etc/webhook.json"
            exit 1
          else
            echo ""
            echo "‚úÖ All webhook deployments successful!"
          fi
