name: CI/CD Pipeline

on:
  push:
    branches: [main]
    paths-ignore:
      - '**.md'
      - '.gitignore'
      - 'LICENSE'
      - 'CLAUDE.md'
      - '.pre-commit-config.yaml'
      - '.yamllint'
      - '.markdownlint.json'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/dependabot.yml'
  pull_request:
    types: [opened, reopened, synchronize, labeled]
    branches: [main]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

permissions:
  contents: write
  packages: write
  pull-requests: write
  issues: write

jobs:
  check-trigger:
    name: Check CI/CD Trigger
    runs-on: ubuntu-slim
    timeout-minutes: 5
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
    steps:
      - name: Remove ci/ready label on new commits
        if: github.event_name == 'pull_request' && github.event.action == 'synchronize'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh pr edit ${{ github.event.pull_request.number }} \
            --repo ${{ github.repository }} \
            --remove-label "ci/ready"

      - name: Check trigger conditions
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "‚úÖ Running CI/CD (push to main)"
            echo "should_run=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            if [[ "${{ contains(github.event.pull_request.labels.*.name, 'ci/ready') }}" == "true" ]]; then
              echo "‚úÖ Running CI/CD (ci/ready label)"
              echo "should_run=true" >> "$GITHUB_OUTPUT"
            else
              echo "‚è≠Ô∏è  Skipping CI/CD (add ci/ready label to run)"
              echo "should_run=false" >> "$GITHUB_OUTPUT"
            fi
            exit 0
          fi

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "‚úÖ Running CI/CD (manual trigger)"
            echo "should_run=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "should_run=false" >> "$GITHUB_OUTPUT"

  lint:
    name: Lint and Validate
    runs-on: ubuntu-slim
    timeout-minutes: 10
    needs: check-trigger
    if: needs.check-trigger.outputs.should_run == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.x'
          cache: 'pip'

      - name: Cache pre-commit environments
        uses: actions/cache@v5
        with:
          path: ~/.cache/pre-commit
          key: pre-commit-${{ hashFiles('.pre-commit-config.yaml') }}
          restore-keys: |
            pre-commit-

      - name: Install hadolint
        run: |
          HADOLINT_VERSION="2.12.0"
          wget -qO /tmp/hadolint \
            "https://github.com/hadolint/hadolint/releases/download/v${HADOLINT_VERSION}/hadolint-Linux-x86_64"
          chmod +x /tmp/hadolint
          sudo mv /tmp/hadolint /usr/local/bin/hadolint
          hadolint --version

      - name: Run pre-commit hooks
        uses: pre-commit/action@v3.0.1
        env:
          SKIP: no-commit-to-branch

      - name: Shellcheck
        run: |
          if command -v shellcheck >/dev/null 2>&1; then
            find . -name "*.sh" -o -name "*.bash" | while read -r file; do
              echo "Checking $file"
              dir=$(dirname "$file")
              (cd "$dir" && shellcheck --external-sources "$(basename "$file")") || exit 1
            done
          else
            echo "Shellcheck not available, skipping"
          fi

  test:
    name: Run Tests
    runs-on: ubuntu-slim
    timeout-minutes: 15
    needs: lint

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Run repository tests
        run: |
          echo "‚úÖ Basic validation passed"
          # Placeholder for repository-specific tests
          # Each repo can customize this section

  semantic-release:
    name: Semantic Release
    runs-on: ubuntu-slim
    timeout-minutes: 10
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.PULL_REQUEST_TOKEN }}  # Needed to push CHANGELOG

      - name: Check for release label
        id: check_label
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Get the PR number from the merge commit
          PR_NUMBER=$(
            gh pr list \
              --state merged \
              --json number,mergeCommit \
              --jq ".[] | select(.mergeCommit.oid == \"${{ github.sha }}\") | .number"
          )

          if [[ -z "$PR_NUMBER" ]]; then
            echo "‚ÑπÔ∏è  Not a PR merge commit, skipping release"
            echo "should_release=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Get PR labels
          LABELS=$(gh pr view "$PR_NUMBER" --json labels --jq '.labels[].name')

          # Check for any release:* label
          if echo "$LABELS" | grep -q "^release:"; then
            echo "‚úÖ Release label found - proceeding with semantic-release"
            echo "should_release=true" >> "$GITHUB_OUTPUT"
          else
            echo "‚ÑπÔ∏è  No release label found - skipping release"
            echo "should_release=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Setup Node.js
        if: steps.check_label.outputs.should_release == 'true'
        uses: actions/setup-node@v6
        with:
          node-version: '24'
          cache: 'npm'

      - name: Install dependencies
        if: steps.check_label.outputs.should_release == 'true'
        run: npm ci

      - name: Run semantic-release
        if: steps.check_label.outputs.should_release == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.PULL_REQUEST_TOKEN }}
        run: npx semantic-release

  build-artifacts:
    name: Build Tarball Artifacts
    runs-on: ubuntu-slim
    timeout-minutes: 10
    needs: semantic-release
    if: startsWith(github.ref, 'refs/tags/')

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Get repository info
        id: repo_info
        run: |
          REPO_NAME="${{ github.event.repository.name }}"
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:7}"

          # Get git version (tag or describe)
          GIT_VERSION=$(git describe --tags --always 2>/dev/null || echo "dev-$SHORT_SHA")

          # Get deployment date (ISO 8601)
          DEPLOY_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          {
            echo "repo_name=$REPO_NAME"
            echo "short_sha=$SHORT_SHA"
            echo "git_version=$GIT_VERSION"
            echo "deploy_date=$DEPLOY_DATE"
          } >> "$GITHUB_OUTPUT"

          echo "üì¶ Repository: $REPO_NAME"
          echo "üì¶ Version: $GIT_VERSION"
          echo "üì¶ Deploy date: $DEPLOY_DATE"

      - name: Replace version placeholders
        run: |
          GIT_VERSION="${{ steps.repo_info.outputs.git_version }}"
          DEPLOY_DATE="${{ steps.repo_info.outputs.deploy_date }}"

          echo "üîÑ Replacing version placeholders..."

          # Find and replace @GIT_VERSION@ placeholder
          if grep -r "@GIT_VERSION@" . --exclude-dir=.git >/dev/null 2>&1; then
            find . -type f -not -path "./.git/*" -exec grep -l "@GIT_VERSION@" {} \; | while read -r file; do
              sed -i "s/@GIT_VERSION@/$GIT_VERSION/g" "$file"
              echo "  ‚úì Updated $file (version)"
            done
          fi

          # Find and replace @DEPLOY_DATE@ placeholder
          if grep -r "@DEPLOY_DATE@" . --exclude-dir=.git >/dev/null 2>&1; then
            find . -type f -not -path "./.git/*" -exec grep -l "@DEPLOY_DATE@" {} \; | while read -r file; do
              sed -i "s/@DEPLOY_DATE@/$DEPLOY_DATE/g" "$file"
              echo "  ‚úì Updated $file (date)"
            done
          fi

          echo "‚úÖ Version placeholder replacement complete"

      - name: Create tarball
        run: |
          REPO_NAME="${{ steps.repo_info.outputs.repo_name }}"
          GIT_VERSION="${{ steps.repo_info.outputs.git_version }}"
          TARBALL="${REPO_NAME}-${GIT_VERSION}.tar.gz"

          echo "üì¶ Creating tarball: $TARBALL"

          # Detect repository structure and create appropriate tarball
          if [[ -d "local-bin"  ||  -d "local-sbin"  ||  -d "local-lib" ]]; then
            # Scripts repo structure: local-bin -> bin transformation
            echo "  üìÅ Structure: local-* (will transform to bin/sbin/lib)"
            tar -czf "$TARBALL" \
              --transform 's|^local-||' \
              local-bin local-sbin local-lib || true
          elif [[ -d "bin"  ||  -d "lib" ]]; then
            # Binary/library structure (e.g., check-minecraft-versions)
            echo "  üìÅ Structure: bin/lib"
            tar -czf "$TARBALL" bin lib 2>/dev/null || \
            tar -czf "$TARBALL" bin 2>/dev/null || true
          else
            # Generic structure: tar everything excluding CI/dev files
            echo "  üìÅ Structure: generic (excluding .git, .github, etc.)"
            tar -czf "$TARBALL" \
              --exclude='.git' \
              --exclude='.github' \
              --exclude='*.tar.gz' \
              --exclude='.pre-commit-config.yaml' \
              --exclude='__pycache__' \
              --exclude='*.pyc' \
              --exclude='.ruff_cache' \
              --exclude='node_modules' \
              --exclude='.pytest_cache' \
              . || true
          fi

          TAR_SIZE=$(stat -c%s "$TARBALL" 2>/dev/null || stat -f%z "$TARBALL")
          echo "‚úÖ Created $TARBALL ($TAR_SIZE bytes)"
          echo "üìã Version: $GIT_VERSION"

          echo "tarball=$TARBALL" >> "$GITHUB_ENV"

      - name: Upload tarball artifact
        uses: actions/upload-artifact@v6
        with:
          name: ${{ steps.repo_info.outputs.repo_name }}-tarball
          path: "*.tar.gz"
          retention-days: 90

  release:
    name: Create Release
    runs-on: ubuntu-slim
    timeout-minutes: 10
    needs: build-artifacts

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Get version
        id: version
        run: |
          # Extract version from tag ref (refs/tags/vX.Y.Z -> vX.Y.Z)
          REF="${{ github.ref }}"
          NEW_VERSION="${REF#refs/tags/}"
          echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "üè∑Ô∏è  Release version: $NEW_VERSION"

      - name: Download tarball artifact
        uses: actions/download-artifact@v7
        with:
          name: ${{ github.event.repository.name }}-tarball

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.new_version }}
          name: Release ${{ steps.version.outputs.new_version }}
          draft: false
          prerelease: false
          generate_release_notes: true
          files: |
            *.tar.gz

      - name: Trigger webhook deployment
        env:
          WEBHOOK_SECRET: ${{ secrets.WEBHOOK_SECRET }}
        run: |
          DEPLOY_SERVERS="${{ vars.DEPLOY_SERVERS }}"
          if [[ -z "$WEBHOOK_SECRET"  ||  -z "$DEPLOY_SERVERS" ]]; then
            echo "‚è≠Ô∏è  Skipping webhook deployment (WEBHOOK_SECRET or DEPLOY_SERVERS not configured)"
            exit 0
          fi

          VERSION="${{ steps.version.outputs.new_version }}"
          REPO="${{ github.repository }}"

          echo "üîî Triggering webhook deployment..."

          # Create webhook payload
          PAYLOAD=$(cat <<EOF
          {
            "action": "deploy-${{ github.event.repository.name }}",
            "version": "$VERSION",
            "repository": "$REPO",
            "tag_name": "$VERSION"
          }
          EOF
          )

          # Calculate HMAC signature
          SIGNATURE=$(printf '%s' "$PAYLOAD" | openssl dgst -sha256 -hmac "$WEBHOOK_SECRET" | sed 's/^.* //')

          # Send webhook to each server
          FAILED_SERVERS=""
          SUCCESS_COUNT=0
          TOTAL_SERVERS=0

          for server in $DEPLOY_SERVERS; do
            ((TOTAL_SERVERS++)) || true
            echo "üì° Sending webhook to $server..."

            RESPONSE=$(curl -L -s -w "\n%{http_code}" -X POST \
              -H "Content-Type: application/json" \
              -H "X-Hub-Signature-256: sha256=$SIGNATURE" \
              --data "$PAYLOAD" \
              "https://$server/hooks/deploy-${{ github.event.repository.name }}" 2>&1 || echo "000")

            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | head -n-1)

            if [[ "$HTTP_CODE" = "200" ]]; then
              echo "  ‚úÖ Webhook delivered to $server"
              ((SUCCESS_COUNT++)) || true
            else
              echo "  ‚ùå Webhook to $server FAILED with HTTP $HTTP_CODE"
              echo "  Response: $BODY"
              FAILED_SERVERS="$FAILED_SERVERS $server"
            fi
          done

          echo ""
          echo "üìä Webhook Deployment Summary:"
          echo "   Total servers: $TOTAL_SERVERS"
          echo "   Successful: $SUCCESS_COUNT"
          echo "   Failed: $((TOTAL_SERVERS - SUCCESS_COUNT))"

          if [[ -n "$FAILED_SERVERS" ]]; then
            echo ""
            echo "‚ùå Webhook deployment FAILED for:$FAILED_SERVERS"
            echo ""
            echo "Troubleshooting:"
            echo "  - Check nginx configuration and IP allowlist on failed servers"
            echo "  - Verify webhook daemon is running: rc-service webhook status"
            echo "  - Check webhook logs: tail -f /var/log/webhook.log"
            echo "  - Verify HMAC secret matches between GitHub and /etc/webhook.json"
            exit 1
          else
            echo ""
            echo "‚úÖ All webhook deployments successful!"
          fi
