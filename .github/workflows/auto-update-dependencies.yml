name: Auto-Update Binary Dependencies

on:
  workflow_dispatch:
    inputs:
      mc_runner_version:
        description: 'mc-server-runner version (optional, will check latest if not provided)'
        required: false
        type: string
      rcon_cli_version:
        description: 'rcon-cli version (optional, will check latest if not provided)'
        required: false
        type: string
      mc_monitor_version:
        description: 'mc-monitor version (optional, will check latest if not provided)'
        required: false
        type: string
      otel_version:
        description: 'OpenTelemetry agent version (optional, will check latest if not provided)'
        required: false
        type: string
  workflow_call:
    inputs:
      mc_runner_version:
        description: 'mc-server-runner version to update to'
        required: false
        type: string
      rcon_cli_version:
        description: 'rcon-cli version to update to'
        required: false
        type: string
      mc_monitor_version:
        description: 'mc-monitor version to update to'
        required: false
        type: string
      otel_version:
        description: 'OpenTelemetry agent version to update to'
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  update-dependencies:
    name: Update Binary Dependencies
    runs-on: ubuntu-slim

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Extract current versions from Dockerfile
        id: current
        run: |
          MC_RUNNER_VERSION=$(grep 'ARG MC_SERVER_RUNNER_VERSION=' Dockerfile | cut -d'=' -f2)
          RCON_CLI_VERSION=$(grep 'ARG RCON_CLI_VERSION=' Dockerfile | cut -d'=' -f2)
          MC_MONITOR_VERSION=$(grep 'ARG MC_MONITOR_VERSION=' Dockerfile | cut -d'=' -f2)
          OTEL_VERSION=$(grep 'ARG OTEL_VERSION=' Dockerfile | cut -d'=' -f2)

          if [ -z "$MC_RUNNER_VERSION" ] || [ -z "$RCON_CLI_VERSION" ] || [ -z "$MC_MONITOR_VERSION" ] || [ -z "$OTEL_VERSION" ]; then
            echo "‚ùå Failed to extract versions from Dockerfile"
            exit 1
          fi

          {
            echo "mc_runner=$MC_RUNNER_VERSION"
            echo "rcon_cli=$RCON_CLI_VERSION"
            echo "mc_monitor=$MC_MONITOR_VERSION"
            echo "otel=$OTEL_VERSION"
          } >> "$GITHUB_OUTPUT"
          echo "üì¶ Current mc-server-runner: $MC_RUNNER_VERSION"
          echo "üì¶ Current rcon-cli: $RCON_CLI_VERSION"
          echo "üì¶ Current mc-monitor: $MC_MONITOR_VERSION"
          echo "üì¶ Current OpenTelemetry agent: $OTEL_VERSION"

      - name: Determine target versions
        id: target
        run: |
          if [ -n "${{ inputs.mc_runner_version }}" ]; then
            MC_RUNNER_LATEST="${{ inputs.mc_runner_version }}"
          else
            # Get the first non-prerelease, non-draft release (more reliable than /releases/latest)
            MC_RUNNER_LATEST=$(curl -sf 'https://api.github.com/repos/itzg/mc-server-runner/releases?per_page=10' | jq -r '[.[] | select(.prerelease == false and .draft == false)][0].tag_name')
            if [ -z "$MC_RUNNER_LATEST" ] || [ "$MC_RUNNER_LATEST" = "null" ]; then
              echo "‚ùå Failed to fetch mc-server-runner latest version"
              exit 1
            fi
          fi

          if [ -n "${{ inputs.rcon_cli_version }}" ]; then
            RCON_CLI_LATEST="${{ inputs.rcon_cli_version }}"
          else
            # Get the first non-prerelease, non-draft release (more reliable than /releases/latest)
            RCON_CLI_LATEST=$(curl -sf 'https://api.github.com/repos/itzg/rcon-cli/releases?per_page=10' | jq -r '[.[] | select(.prerelease == false and .draft == false)][0].tag_name')
            if [ -z "$RCON_CLI_LATEST" ] || [ "$RCON_CLI_LATEST" = "null" ]; then
              echo "‚ùå Failed to fetch rcon-cli latest version"
              exit 1
            fi
          fi

          if [ -n "${{ inputs.mc_monitor_version }}" ]; then
            MC_MONITOR_LATEST="${{ inputs.mc_monitor_version }}"
          else
            # Get the first non-prerelease, non-draft release (more reliable than /releases/latest)
            MC_MONITOR_LATEST=$(curl -sf 'https://api.github.com/repos/itzg/mc-monitor/releases?per_page=10' | jq -r '[.[] | select(.prerelease == false and .draft == false)][0].tag_name')
            if [ -z "$MC_MONITOR_LATEST" ] || [ "$MC_MONITOR_LATEST" = "null" ]; then
              echo "‚ùå Failed to fetch mc-monitor latest version"
              exit 1
            fi
          fi

          if [ -n "${{ inputs.otel_version }}" ]; then
            OTEL_LATEST="${{ inputs.otel_version }}"
          else
            # Get the first non-prerelease, non-draft release (more reliable than /releases/latest)
            OTEL_LATEST=$(curl -sf 'https://api.github.com/repos/open-telemetry/opentelemetry-java-instrumentation/releases?per_page=10' | jq -r '[.[] | select(.prerelease == false and .draft == false)][0].tag_name' | sed 's/^v//')
            if [ -z "$OTEL_LATEST" ] || [ "$OTEL_LATEST" = "null" ]; then
              echo "‚ùå Failed to fetch OpenTelemetry agent latest version"
              exit 1
            fi
          fi

          {
            echo "mc_runner=$MC_RUNNER_LATEST"
            echo "rcon_cli=$RCON_CLI_LATEST"
            echo "mc_monitor=$MC_MONITOR_LATEST"
            echo "otel=$OTEL_LATEST"
          } >> "$GITHUB_OUTPUT"
          echo "üîç Target mc-server-runner: $MC_RUNNER_LATEST"
          echo "üîç Target rcon-cli: $RCON_CLI_LATEST"
          echo "üîç Target mc-monitor: $MC_MONITOR_LATEST"
          echo "üîç Target OpenTelemetry agent: $OTEL_LATEST"

      - name: Check if updates are needed
        id: check
        run: |
          CURRENT_MC_RUNNER="${{ steps.current.outputs.mc_runner }}"
          TARGET_MC_RUNNER="${{ steps.target.outputs.mc_runner }}"
          CURRENT_RCON_CLI="${{ steps.current.outputs.rcon_cli }}"
          TARGET_RCON_CLI="${{ steps.target.outputs.rcon_cli }}"
          CURRENT_MC_MONITOR="${{ steps.current.outputs.mc_monitor }}"
          TARGET_MC_MONITOR="${{ steps.target.outputs.mc_monitor }}"
          CURRENT_OTEL="${{ steps.current.outputs.otel }}"
          TARGET_OTEL="${{ steps.target.outputs.otel }}"

          UPDATE_NEEDED=false

          if [ "$CURRENT_MC_RUNNER" != "$TARGET_MC_RUNNER" ]; then
            echo "mc_runner_update=true" >> "$GITHUB_OUTPUT"
            UPDATE_NEEDED=true
            echo "‚ö†Ô∏è mc-server-runner update needed: $CURRENT_MC_RUNNER ‚Üí $TARGET_MC_RUNNER"
          else
            echo "mc_runner_update=false" >> "$GITHUB_OUTPUT"
            echo "‚úÖ mc-server-runner is up to date: $CURRENT_MC_RUNNER"
          fi

          if [ "$CURRENT_RCON_CLI" != "$TARGET_RCON_CLI" ]; then
            echo "rcon_cli_update=true" >> "$GITHUB_OUTPUT"
            UPDATE_NEEDED=true
            echo "‚ö†Ô∏è rcon-cli update needed: $CURRENT_RCON_CLI ‚Üí $TARGET_RCON_CLI"
          else
            echo "rcon_cli_update=false" >> "$GITHUB_OUTPUT"
            echo "‚úÖ rcon-cli is up to date: $CURRENT_RCON_CLI"
          fi

          if [ "$CURRENT_MC_MONITOR" != "$TARGET_MC_MONITOR" ]; then
            echo "mc_monitor_update=true" >> "$GITHUB_OUTPUT"
            UPDATE_NEEDED=true
            echo "‚ö†Ô∏è mc-monitor update needed: $CURRENT_MC_MONITOR ‚Üí $TARGET_MC_MONITOR"
          else
            echo "mc_monitor_update=false" >> "$GITHUB_OUTPUT"
            echo "‚úÖ mc-monitor is up to date: $CURRENT_MC_MONITOR"
          fi

          if [ "$CURRENT_OTEL" != "$TARGET_OTEL" ]; then
            echo "otel_update=true" >> "$GITHUB_OUTPUT"
            UPDATE_NEEDED=true
            echo "‚ö†Ô∏è OpenTelemetry agent update needed: $CURRENT_OTEL ‚Üí $TARGET_OTEL"
          else
            echo "otel_update=false" >> "$GITHUB_OUTPUT"
            echo "‚úÖ OpenTelemetry agent is up to date: $CURRENT_OTEL"
          fi

          if [ "$UPDATE_NEEDED" = true ]; then
            echo "updates_needed=true" >> "$GITHUB_OUTPUT"
            echo "üìù Updates are needed"
          else
            echo "updates_needed=false" >> "$GITHUB_OUTPUT"
            echo "‚úÖ All dependencies are up to date"
          fi

      - name: Debug authenticated user for PAT
        if: steps.check.outputs.updates_needed == 'true'
        run: |
          echo "Checking authenticated user for PULL_REQUEST_TOKEN (will not reveal token)"
          curl -fsSL -H "Authorization: token ${{ secrets.PULL_REQUEST_TOKEN }}" https://api.github.com/user | jq -r '.login, .id'

      - name: Create PR with updates
        if: steps.check.outputs.updates_needed == 'true'
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.PULL_REQUEST_TOKEN }}
          script: |
            const currentMcRunner = '${{ steps.current.outputs.mc_runner }}';
            const targetMcRunner = '${{ steps.target.outputs.mc_runner }}';
            const currentRconCli = '${{ steps.current.outputs.rcon_cli }}';
            const targetRconCli = '${{ steps.target.outputs.rcon_cli }}';
            const currentMcMonitor = '${{ steps.current.outputs.mc_monitor }}';
            const targetMcMonitor = '${{ steps.target.outputs.mc_monitor }}';
            const currentOtel = '${{ steps.current.outputs.otel }}';
            const targetOtel = '${{ steps.target.outputs.otel }}';
            const mcRunnerUpdate = '${{ steps.check.outputs.mc_runner_update }}' === 'true';
            const rconCliUpdate = '${{ steps.check.outputs.rcon_cli_update }}' === 'true';
            const mcMonitorUpdate = '${{ steps.check.outputs.mc_monitor_update }}' === 'true';
            const otelUpdate = '${{ steps.check.outputs.otel_update }}' === 'true';

            // Generate branch name by concatenating updated components
            const updatedComponents = [];
            if (mcRunnerUpdate) updatedComponents.push('mc-runner');
            if (rconCliUpdate) updatedComponents.push('rcon-cli');
            if (mcMonitorUpdate) updatedComponents.push('mc-monitor');
            if (otelUpdate) updatedComponents.push('otel');
            const branchSuffix = updatedComponents.join('-');

            const branchName = `chore/update-binary-deps-${branchSuffix}`;

            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:${branchName}`
            });

            if (prs.data.length > 0) {
              console.log(`PR already exists: #${prs.data[0].number}`);
              return;
            }

            try {
              const { data: ref } = await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: 'heads/main'
              });

              // Check if branch already exists and delete it (only safe because we confirmed no PR exists above)
              try {
                await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${branchName}`
                });
                console.log(`‚ö†Ô∏è Branch ${branchName} already exists (no active PR), deleting it...`);

                // Delete the existing branch
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${branchName}`
                });
                console.log(`‚úÖ Deleted existing branch: ${branchName}`);
              } catch (error) {
                if (error.status !== 404) {
                  throw error;
                }
                // Branch doesn't exist, which is fine
              }

              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/heads/${branchName}`,
                sha: ref.object.sha
              });

              console.log(`‚úÖ Created branch: ${branchName}`);

              const { data: dockerfileData } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'Dockerfile',
                ref: branchName
              });

              let dockerfile = Buffer.from(dockerfileData.content, 'base64').toString('utf8');

              if (mcRunnerUpdate) {
                dockerfile = dockerfile.replace(
                  /ARG MC_SERVER_RUNNER_VERSION=[^\s\r\n]+/,
                  `ARG MC_SERVER_RUNNER_VERSION=${targetMcRunner}`
                );
                console.log(`‚úÖ Updated mc-server-runner: ${currentMcRunner} ‚Üí ${targetMcRunner}`);
              }

              if (rconCliUpdate) {
                dockerfile = dockerfile.replace(
                  /ARG RCON_CLI_VERSION=[^\s\r\n]+/,
                  `ARG RCON_CLI_VERSION=${targetRconCli}`
                );
                console.log(`‚úÖ Updated rcon-cli: ${currentRconCli} ‚Üí ${targetRconCli}`);
              }

              if (mcMonitorUpdate) {
                dockerfile = dockerfile.replace(
                  /ARG MC_MONITOR_VERSION=[^\s\r\n]+/,
                  `ARG MC_MONITOR_VERSION=${targetMcMonitor}`
                );
                console.log(`‚úÖ Updated mc-monitor: ${currentMcMonitor} ‚Üí ${targetMcMonitor}`);
              }

              if (otelUpdate) {
                dockerfile = dockerfile.replace(
                  /ARG OTEL_VERSION=[^\s\r\n]+/,
                  `ARG OTEL_VERSION=${targetOtel}`
                );
                console.log(`‚úÖ Updated OpenTelemetry agent: ${currentOtel} ‚Üí ${targetOtel}`);
              }

              await github.rest.repos.createOrUpdateFileContents({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'Dockerfile',
                message: 'chore: update binary dependency versions',
                content: Buffer.from(dockerfile).toString('base64'),
                sha: dockerfileData.sha,
                branch: branchName
              });

              console.log('‚úÖ Updated Dockerfile');

              let updates = [];
              if (mcRunnerUpdate) {
                updates.push(`- **mc-server-runner**: ${currentMcRunner} ‚Üí ${targetMcRunner}`);
              }
              if (rconCliUpdate) {
                updates.push(`- **rcon-cli**: ${currentRconCli} ‚Üí ${targetRconCli}`);
              }
              if (mcMonitorUpdate) {
                updates.push(`- **mc-monitor**: ${currentMcMonitor} ‚Üí ${targetMcMonitor}`);
              }
              if (otelUpdate) {
                updates.push(`- **OpenTelemetry Java agent**: ${currentOtel} ‚Üí ${targetOtel}`);
              }

              let releaseLinks = [];
              if (mcRunnerUpdate) {
                releaseLinks.push(`- [mc-server-runner ${targetMcRunner}](https://github.com/itzg/mc-server-runner/releases/tag/${targetMcRunner})`);
              }
              if (rconCliUpdate) {
                releaseLinks.push(`- [rcon-cli ${targetRconCli}](https://github.com/itzg/rcon-cli/releases/tag/${targetRconCli})`);
              }
              if (mcMonitorUpdate) {
                releaseLinks.push(`- [mc-monitor ${targetMcMonitor}](https://github.com/itzg/mc-monitor/releases/tag/${targetMcMonitor})`);
              }
              if (otelUpdate) {
                releaseLinks.push(`- [OpenTelemetry Java agent v${targetOtel}](https://github.com/open-telemetry/opentelemetry-java-instrumentation/releases/tag/v${targetOtel})`);
              }

              const prBody = [
                '## Update Binary Dependencies',
                '',
                'This PR updates the following binary dependencies to their latest versions:',
                '',
                updates.join('\n'),
                '',
                '### Release Notes',
                '',
                releaseLinks.join('\n'),
                '',
                '### Changes Made',
                '',
                '- Updated version numbers in `Dockerfile`',
                '- Container will download new binaries during build',
                '',
                '### Testing',
                '',
                'The CI/CD pipeline will:',
                '1. Lint the Dockerfile with hadolint',
                '2. Build the container with new binaries',
                '3. Run integration tests with Paper server',
                '',
                'To test locally:',
                '',
                '```bash',
                'docker build -t mc-server-container:test .',
                'docker run -d --name mc-test -e EULA=TRUE mc-server-container:test',
                'docker logs mc-test',
                'docker stop mc-test && docker rm mc-test',
                '```',
                '',
                '---',
                '*This PR was automatically created by the auto-update-dependencies workflow.*'
              ].join('\n');

              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: 'chore: update binary dependency versions',
                head: branchName,
                base: 'main',
                body: prBody
              });

              console.log(`‚úÖ Created PR #${pr.number}`);

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['dependencies', 'automated', 'release:patch']
              });

              console.log('‚úÖ Added labels to PR');

              const issues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: 'dependencies,automated',
                state: 'open'
              });

              for (const issue of issues.data) {
                if (issue.title.includes('Binary dependency updates available')) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `Automated PR created: #${pr.number}\n\nClosing this issue as the updates are now in progress.`
                  });

                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    state: 'closed'
                  });

                  console.log(`‚úÖ Closed issue #${issue.number}`);
                }
              }

            } catch (error) {
              console.error('Error:', error);
              throw error;
            }
