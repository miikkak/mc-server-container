name: Dependency Check

on:
  schedule:
    # Run every Monday at 09:00 UTC
    - cron: '0 9 * * 1'
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: read
  issues: write
  actions: write

jobs:
  check-binary-dependencies:
    name: Check Binary Dependencies
    runs-on: ubuntu-slim

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Extract current versions from Dockerfile
        id: current
        run: |
          MC_RUNNER_VERSION=$(grep 'ARG MC_SERVER_RUNNER_VERSION=' Dockerfile | cut -d'=' -f2)
          RCON_CLI_VERSION=$(grep 'ARG RCON_CLI_VERSION=' Dockerfile | cut -d'=' -f2)
          MC_MONITOR_VERSION=$(grep 'ARG MC_MONITOR_VERSION=' Dockerfile | cut -d'=' -f2)
          OTEL_VERSION=$(grep 'ARG OTEL_VERSION=' Dockerfile | cut -d'=' -f2)
          echo "mc_runner=$MC_RUNNER_VERSION" >> $GITHUB_OUTPUT
          echo "rcon_cli=$RCON_CLI_VERSION" >> $GITHUB_OUTPUT
          echo "mc_monitor=$MC_MONITOR_VERSION" >> $GITHUB_OUTPUT
          echo "otel=$OTEL_VERSION" >> $GITHUB_OUTPUT
          echo "üì¶ Current mc-server-runner: $MC_RUNNER_VERSION"
          echo "üì¶ Current rcon-cli: $RCON_CLI_VERSION"
          echo "üì¶ Current mc-monitor: $MC_MONITOR_VERSION"
          echo "üì¶ Current OpenTelemetry agent: $OTEL_VERSION"

      - name: Check mc-server-runner latest release
        id: mc_runner
        run: |
          # Get first non-prerelease, non-draft release (more reliable than /releases/latest)
          LATEST=$(curl -sf 'https://api.github.com/repos/itzg/mc-server-runner/releases?per_page=10' | jq -r '[.[] | select(.prerelease == false and .draft == false)][0].tag_name')
          if [ -z "$LATEST" ] || [ "$LATEST" = "null" ]; then
            echo "‚ùå Failed to fetch mc-server-runner latest version"
            exit 1
          fi
          echo "latest=$LATEST" >> $GITHUB_OUTPUT
          echo "üîç Latest mc-server-runner: $LATEST"

      - name: Check rcon-cli latest release
        id: rcon_cli
        run: |
          # Get the first non-prerelease, non-draft release (more reliable than /releases/latest)
          LATEST=$(curl -sf 'https://api.github.com/repos/itzg/rcon-cli/releases?per_page=10' | jq -r '[.[] | select(.prerelease == false and .draft == false)][0].tag_name')
          if [ -z "$LATEST" ] || [ "$LATEST" = "null" ]; then
            echo "‚ùå Failed to fetch rcon-cli latest version"
            exit 1
          fi
          echo "latest=$LATEST" >> $GITHUB_OUTPUT
          echo "üîç Latest rcon-cli: $LATEST"

      - name: Check mc-monitor latest release
        id: mc_monitor
        run: |
          # Get the first non-prerelease, non-draft release (more reliable than /releases/latest)
          LATEST=$(curl -sf 'https://api.github.com/repos/itzg/mc-monitor/releases?per_page=10' | jq -r '[.[] | select(.prerelease == false and .draft == false)][0].tag_name')
          if [ -z "$LATEST" ] || [ "$LATEST" = "null" ]; then
            echo "‚ùå Failed to fetch mc-monitor latest version"
            exit 1
          fi
          echo "latest=$LATEST" >> $GITHUB_OUTPUT
          echo "üîç Latest mc-monitor: $LATEST"

      - name: Check OpenTelemetry agent latest release
        id: otel
        run: |
          # Get the first non-prerelease, non-draft release (more reliable than /releases/latest)
          LATEST=$(curl -sf 'https://api.github.com/repos/open-telemetry/opentelemetry-java-instrumentation/releases?per_page=10' | jq -r '[.[] | select(.prerelease == false and .draft == false)][0].tag_name' | sed 's/^v//')
          if [ -z "$LATEST" ] || [ "$LATEST" = "null" ]; then
            echo "‚ùå Failed to fetch OpenTelemetry agent latest version"
            exit 1
          fi
          echo "latest=$LATEST" >> $GITHUB_OUTPUT
          echo "üîç Latest OpenTelemetry agent: $LATEST"

      - name: Compare versions and create issue if needed
        id: compare
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.PULL_REQUEST_TOKEN }}
          script: |
            const currentMcRunner = '${{ steps.current.outputs.mc_runner }}';
            const latestMcRunner = '${{ steps.mc_runner.outputs.latest }}';
            const currentRconCli = '${{ steps.current.outputs.rcon_cli }}';
            const latestRconCli = '${{ steps.rcon_cli.outputs.latest }}';
            const currentMcMonitor = '${{ steps.current.outputs.mc_monitor }}';
            const latestMcMonitor = '${{ steps.mc_monitor.outputs.latest }}';
            const currentOtel = '${{ steps.current.outputs.otel }}';
            const latestOtel = '${{ steps.otel.outputs.latest }}';

            let updates = [];

            if (currentMcRunner !== latestMcRunner) {
              updates.push(`- **mc-server-runner**: ${currentMcRunner} ‚Üí ${latestMcRunner}`);
            }

            if (currentRconCli !== latestRconCli) {
              updates.push(`- **rcon-cli**: ${currentRconCli} ‚Üí ${latestRconCli}`);
            }

            if (currentMcMonitor !== latestMcMonitor) {
              updates.push(`- **mc-monitor**: ${currentMcMonitor} ‚Üí ${latestMcMonitor}`);
            }

            if (currentOtel !== latestOtel) {
              updates.push(`- **OpenTelemetry Java agent**: ${currentOtel} ‚Üí ${latestOtel}`);
            }

            if (updates.length === 0) {
              console.log('‚úÖ All dependencies are up to date!');
              core.setOutput('updates_available', 'false');
              return;
            }

            // Check if an issue already exists
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'dependencies,automated',
              state: 'open'
            });

            const existingIssue = issues.data.find(issue =>
              issue.title.includes('Binary dependency updates available')
            );

            const body = `## Binary Dependency Updates Available

            The following binary dependencies have new versions available:

            ${updates.join('\n')}

            ### Update Instructions

            1. Update the versions in the \`Dockerfile\`:
               \`\`\`dockerfile
               ARG MC_SERVER_RUNNER_VERSION=${latestMcRunner}
               ARG RCON_CLI_VERSION=${latestRconCli}
               ARG MC_MONITOR_VERSION=${latestMcMonitor}
               ARG OTEL_VERSION=${latestOtel}
               \`\`\`

            2. Test the build locally:
               \`\`\`bash
               docker build -t mc-server-container:test .
               \`\`\`

            3. Create a PR with the changes and add the \`release:patch\` label.

            ---
            *This issue was automatically created by the dependency-check workflow.*
            *Last checked: ${new Date().toISOString()}*`;

            if (existingIssue) {
              // Update existing issue
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: body
              });
              console.log(`üìù Updated existing issue #${existingIssue.number}`);
            } else {
              // Create new issue
              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: '‚¨ÜÔ∏è Binary dependency updates available',
                body: body,
                labels: ['dependencies', 'automated', 'enhancement']
              });
              console.log(`üìù Created new issue #${newIssue.data.number}`);
            }

            // Set outputs for triggering auto-update workflow
            core.setOutput('updates_available', 'true');
            core.setOutput('mc_runner_latest', latestMcRunner);
            core.setOutput('rcon_cli_latest', latestRconCli);
            core.setOutput('mc_monitor_latest', latestMcMonitor);
            core.setOutput('otel_latest', latestOtel);

      - name: Trigger auto-update workflow
        if: steps.compare.outputs.updates_available == 'true'
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.PULL_REQUEST_TOKEN }}
          script: |
            const mcRunnerVersion = '${{ steps.mc_runner.outputs.latest }}';
            const rconCliVersion = '${{ steps.rcon_cli.outputs.latest }}';
            const mcMonitorVersion = '${{ steps.mc_monitor.outputs.latest }}';
            const otelVersion = '${{ steps.otel.outputs.latest }}';

            console.log('ü§ñ Triggering auto-update workflow...');
            console.log(`  mc-server-runner: ${mcRunnerVersion}`);
            console.log(`  rcon-cli: ${rconCliVersion}`);
            console.log(`  mc-monitor: ${mcMonitorVersion}`);
            console.log(`  OpenTelemetry agent: ${otelVersion}`);

            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'auto-update-dependencies.yml',
              ref: 'main',
              inputs: {
                mc_runner_version: mcRunnerVersion,
                rcon_cli_version: rconCliVersion,
                mc_monitor_version: mcMonitorVersion,
                otel_version: otelVersion
              }
            });

            console.log('‚úÖ Auto-update workflow triggered successfully');

  check-base-image:
    name: Check Base Image Updates
    runs-on: ubuntu-latest
    env:
      DIGEST_FILE: .github/.docker-base-digest.txt

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Check GraalVM base image
        id: check_image
        run: |
          # Extract current base image
          CURRENT_IMAGE=$(grep '^FROM container-registry.oracle.com/graalvm/jdk:' Dockerfile | head -1 | awk '{print $2}')
          echo "current=$CURRENT_IMAGE" >> $GITHUB_OUTPUT
          echo "üì¶ Current base image: $CURRENT_IMAGE"

          # Read the last known digest from stored file
          if [ -f "$DIGEST_FILE" ]; then
            STORED_DIGEST=$(cat "$DIGEST_FILE" | tr -d '[:space:]')
            echo "üì¶ Stored digest: $STORED_DIGEST"
          else
            STORED_DIGEST="unknown"
            echo "‚ö†Ô∏è No stored digest found"
          fi
          echo "current_digest=$STORED_DIGEST" >> $GITHUB_OUTPUT

          # Get latest manifest digest from registry using buildx imagetools
          # This gets the digest of the manifest list/index
          LATEST_DIGEST=$(docker buildx imagetools inspect "$CURRENT_IMAGE" --format '{{.Manifest.Digest}}' 2>&1 | awk '/^Digest:/ {print $2}' || echo "unknown")
          echo "latest_digest=$LATEST_DIGEST" >> $GITHUB_OUTPUT
          echo "üì¶ Latest registry digest: $LATEST_DIGEST"

          # Compare digests to check if an update is available
          if [ "$STORED_DIGEST" = "unknown" ] || [ "$LATEST_DIGEST" = "unknown" ]; then
            echo "update_available=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Could not determine digest(s), skipping update check"
          elif [ "$STORED_DIGEST" != "$LATEST_DIGEST" ]; then
            echo "update_available=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Base image has updates available"
            echo "   $STORED_DIGEST ‚Üí $LATEST_DIGEST"
          else
            echo "update_available=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Base image is up to date"
          fi

      - name: Create issue if update available
        if: steps.check_image.outputs.update_available == 'true'
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.PULL_REQUEST_TOKEN }}
          script: |
            const currentImage = '${{ steps.check_image.outputs.current }}';
            const currentDigest = '${{ steps.check_image.outputs.current_digest }}';
            const latestDigest = '${{ steps.check_image.outputs.latest_digest }}';

            // Check if an issue already exists
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'dependencies,docker,automated',
              state: 'open'
            });

            const existingIssue = issues.data.find(issue =>
              issue.title.includes('GraalVM base image update available')
            );

            if (existingIssue) {
              console.log(`Issue already exists: #${existingIssue.number}`);
              return;
            }

            const body = `## GraalVM Base Image Update Available

            A new version of the GraalVM base image is available.

            **Current Image:** \`${currentImage}\`
            **Current Digest:** \`${currentDigest}\`
            **Latest Digest:** \`${latestDigest}\`

            ### Update Instructions

            1. Update the stored digest file:
               \`\`\`bash
               echo "${latestDigest}" > .github/.docker-base-digest.txt
               \`\`\`

            2. Rebuild the container to pull the latest base image:
               \`\`\`bash
               docker build --no-cache --pull -t mc-server-container:test .
               \`\`\`

            3. Test the updated container:
               \`\`\`bash
               docker run -d --name mc-test -e EULA=TRUE mc-server-container:test
               docker logs mc-test
               docker stop mc-test && docker rm mc-test
               \`\`\`

            4. If tests pass, create a PR with the digest file update and add the \`release:patch\` label.

            ---
            *This issue was automatically created by the dependency-check workflow.*
            *Checked on: ${new Date().toISOString()}*`;

            const newIssue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '‚¨ÜÔ∏è GraalVM base image update available',
              body: body,
              labels: ['dependencies', 'docker', 'automated', 'enhancement']
            });
            console.log(`üìù Created issue #${newIssue.data.number}`);

      - name: Trigger base image auto-update workflow
        if: steps.check_image.outputs.update_available == 'true'
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.PULL_REQUEST_TOKEN }}
          script: |
            const latestDigest = '${{ steps.check_image.outputs.latest_digest }}';

            console.log('ü§ñ Triggering base image auto-update workflow...');
            console.log(`  Latest digest: ${latestDigest}`);

            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'auto-update-base-image.yml',
                ref: 'main',
                inputs: {
                  digest: latestDigest
                }
              });

              console.log('‚úÖ Auto-update workflow triggered successfully');
            } catch (error) {
              console.error('‚ùå Failed to trigger auto-update workflow:', error.message);
              // Don't fail the job if triggering auto-update fails
              // The issue was already created, so manual update is still possible
            }
