name: Cache Cleanup

on:
  schedule:
    # Run every Sunday at 02:00 UTC
    - cron: '0 2 * * 0'
  workflow_dispatch: # Allow manual trigger

permissions:
  actions: write
  contents: read

jobs:
  cleanup-caches:
    name: Clean Up Stale Caches
    runs-on: ubuntu-slim

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Cleanup old caches
        uses: actions/github-script@v8
        with:
          script: |
            const CACHE_AGE_DAYS = 7;
            const DELETED_BRANCH_MIN_AGE_DAYS = 2;
            const now = Date.now();
            const maxAge = CACHE_AGE_DAYS * 24 * 60 * 60 * 1000;
            const deletedBranchMinAge = DELETED_BRANCH_MIN_AGE_DAYS * 24 * 60 * 60 * 1000;

            console.log(`ðŸ§¹ Starting cache cleanup`);
            console.log(`   - Removing caches older than ${CACHE_AGE_DAYS} days`);
            console.log(`   - Removing caches from deleted branches (older than ${DELETED_BRANCH_MIN_AGE_DAYS} days)`);

            // Get all caches
            const caches = await github.paginate(github.rest.actions.getActionsCacheList, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });

            console.log(`ðŸ“¦ Found ${caches.length} total caches`);

            let deletedCount = 0;
            let deletedSize = 0;

            for (const cache of caches) {
              const cacheAge = now - new Date(cache.created_at).getTime();
              const cacheAgeDays = Math.floor(cacheAge / (24 * 60 * 60 * 1000));

              // Delete caches that are:
              // 1. Older than CACHE_AGE_DAYS
              // 2. From deleted branches (with minimum age threshold to allow for rollbacks/reuse)
              let shouldDelete = false;
              let reason = '';

              if (cacheAge > maxAge) {
                shouldDelete = true;
                reason = `older than ${CACHE_AGE_DAYS} days (${cacheAgeDays} days old)`;
              } else if (cache.ref && cache.ref !== 'refs/heads/main') {
                // Check if ref still exists (only for caches older than minimum age)
                if (cacheAge > deletedBranchMinAge) {
                  // Handle pull request refs differently
                  if (cache.ref.startsWith('refs/pull/')) {
                    // Extract PR number from refs/pull/123/merge
                    const prMatch = cache.ref.match(/^refs\/pull\/(\d+)\//);
                    if (prMatch) {
                      const prNumber = parseInt(prMatch[1], 10);
                      try {
                        const pr = await github.rest.pulls.get({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          pull_number: prNumber
                        });
                        // Delete cache if PR is closed/merged
                        if (pr.data.state === 'closed') {
                          shouldDelete = true;
                          reason = `PR #${prNumber} is closed (${cache.ref}, ${cacheAgeDays} days old)`;
                        }
                      } catch (error) {
                        if (error.status === 404) {
                          shouldDelete = true;
                          reason = `PR no longer exists (${cache.ref}, ${cacheAgeDays} days old)`;
                        } else {
                          console.log(`âš ï¸  Could not verify PR ${cache.ref}: ${error.message} (status: ${error.status ?? 'unknown'})`);
                        }
                      }
                    }
                  } else {
                    // Handle branch refs
                    try {
                      await github.rest.git.getRef({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        ref: cache.ref.replace('refs/', '')
                      });
                    } catch (error) {
                      if (error.status === 404) {
                        shouldDelete = true;
                        reason = `branch no longer exists (${cache.ref}, ${cacheAgeDays} days old)`;
                      } else {
                        console.log(`âš ï¸  Could not verify branch ${cache.ref}: ${error.message} (status: ${error.status ?? 'unknown'})`);
                      }
                    }
                  }
                }
              }

              if (shouldDelete) {
                try {
                  await github.rest.actions.deleteActionsCacheById({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    cache_id: cache.id
                  });

                  deletedCount++;
                  deletedSize += cache.size_in_bytes || 0;

                  const sizeMB = ((cache.size_in_bytes || 0) / 1024 / 1024).toFixed(2);
                  console.log(`ðŸ—‘ï¸  Deleted cache ${cache.id} (${cache.key}): ${sizeMB} MB - ${reason}`);
                } catch (error) {
                  console.log(`âš ï¸  Failed to delete cache ${cache.id}: ${error.message}`);
                }
              }
            }

            const totalSizeMB = (deletedSize / 1024 / 1024).toFixed(2);
            console.log('');
            console.log(`âœ… Cache cleanup complete`);
            console.log(`   Deleted: ${deletedCount} caches`);
            console.log(`   Freed: ${totalSizeMB} MB`);
            console.log(`   Remaining: ${caches.length - deletedCount} caches`);

      - name: Summary
        run: |
          echo "### ðŸ§¹ Cache Cleanup Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Cache cleanup completed successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Check the logs above for details on deleted caches." >> $GITHUB_STEP_SUMMARY
