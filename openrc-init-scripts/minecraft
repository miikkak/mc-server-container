#!/sbin/openrc-run
# shellcheck shell=bash
# Copyright 2025 Gentoo Authors
# Distributed under the terms of the GNU General Public License v2

# shellcheck disable=SC2034
name="Minecraft Server"
# shellcheck disable=SC2034
description="Minecraft server in Podman container"

# Default configuration values (can be overridden in /etc/conf.d/minecraft)
CONTAINER_NAME="${CONTAINER_NAME:-mc}"
CONTAINER_IMAGE="${CONTAINER_IMAGE:-ghcr.io/miikkak/mc-server-container:latest}"
CONTAINER_MEMORY="${CONTAINER_MEMORY:-24G}"
CONTAINER_STOP_TIMEOUT="${CONTAINER_STOP_TIMEOUT:-120}"

NETWORK_NAME="${NETWORK_NAME:-minecraft-net}"
NETWORK_SUBNET="${NETWORK_SUBNET:-10.10.10.0/24}"
NETWORK_GATEWAY="${NETWORK_GATEWAY:-10.10.10.1}"
CONTAINER_IP="${CONTAINER_IP:-10.10.10.10}"
CONTAINER_IPv6="${CONTAINER_IPv6:-2a01:4f9:3070:1169::b10c:cafe}"

CONTAINER_VOLUMES="${CONTAINER_VOLUMES:-/srv/minecraft:/data /srv/bluemap:/data/bluemap}"
CONTAINER_PORTS="${CONTAINER_PORTS:-127.0.0.1:8100:8100 127.0.0.1:9000:9000 127.0.0.1:9940:9940 19132:19132/udp 25565:25565/udp 25565:25565/tcp}"
CONTAINER_ENV="${CONTAINER_ENV:-OTEL_JAVAAGENT_CONFIGURATION_FILE=/data/otel-config.properties}"
CONTAINER_LABELS="${CONTAINER_LABELS:-minecraft.server=true minecraft.name=CubeSchool}"
NETWORK_DISABLE_DNS="${NETWORK_DISABLE_DNS:-true}"

depend() {
  need net
  use podman ndppd
  after firewall
}

start_pre() {
  # Ensure network exists
  if ! podman network exists "${NETWORK_NAME}" >/dev/null 2>&1; then
    ebegin "Creating Podman network ${NETWORK_NAME}"
    local disable_dns_flag=""
    if [ "${NETWORK_DISABLE_DNS}" = "true" ]; then
      disable_dns_flag="--disable-dns"
    fi
    podman network create \
      --subnet "${NETWORK_SUBNET}" \
      --gateway "${NETWORK_GATEWAY}" \
      --interface-name "${NETWORK_NAME}" \
      ${disable_dns_flag} \
      "${NETWORK_NAME}"
    eend $?
  fi
}

start() {
  local ret=1
  ebegin "Starting ${name}"

  # Check if container already exists
  if podman container exists "${CONTAINER_NAME}"; then
    # Container exists, just start it
    podman start "${CONTAINER_NAME}"
    ret=$?
  else
    # Build volume arguments
    local volume_args=()
    for vol in ${CONTAINER_VOLUMES}; do
      volume_args+=("-v" "${vol}")
    done

    # Build port arguments
    local port_args=()
    for port in ${CONTAINER_PORTS}; do
      port_args+=("-p" "${port}")
    done

    # Build environment arguments
    local env_args=()
    for env in ${CONTAINER_ENV}; do
      env_args+=("-e" "${env}")
    done

    # Build label arguments
    local label_args=()
    for label in ${CONTAINER_LABELS}; do
      label_args+=("--label" "${label}")
    done

    # Create and start new container
    podman run -d \
      --name "${CONTAINER_NAME}" \
      --memory "${CONTAINER_MEMORY}" \
      --network "${NETWORK_NAME}" \
      --ip "${CONTAINER_IP}" \
      --stop-timeout "${CONTAINER_STOP_TIMEOUT}" \
      "${volume_args[@]}" \
      "${port_args[@]}" \
      "${env_args[@]}" \
      "${label_args[@]}" \
      "${CONTAINER_IMAGE}"
    ret=$?
  fi

  if [ $ret -eq 0 ]; then
    # Wait for container to be running
    podman wait --condition=running "${CONTAINER_NAME}" || ret=1

    if [ $ret -eq 0 ]; then
      # Setup IPv6
      setup_ipv6
      local ipv6_ret=$?
      [ $ipv6_ret -ne 0 ] && ret=$ipv6_ret
    fi

  fi
  eend $ret
}

setup_ipv6() {
  local container_pid bridge_ll_addr
  container_pid=$(podman inspect "${CONTAINER_NAME}" --format '{{.State.Pid}}')

  # Validate container_pid is a positive integer using POSIX-compliant case statement
  case "$container_pid" in
    ''|*[!0-9]*)
      ewarn "Could not get container PID for IPv6 setup"
      return 1
      ;;
    *)
      [ "$container_pid" -gt 0 ] || {
        ewarn "Could not get container PID for IPv6 setup"
        return 1
      }
      ;;
  esac

  ebegin "Configuring IPv6 for ${name}"

  # Add route to container (ndppd handles NDP proxy)
  ip -6 route replace "${CONTAINER_IPv6}" dev "${NETWORK_NAME}"
  local status1=$?

  # Get bridge link-local address
  bridge_ll_addr=$(ip -6 addr show dev "${NETWORK_NAME}" scope link | awk '/inet6 fe80/ {split($2, a, "/"); print a[1]; exit}')

  # Configure container IPv6 as /128
  nsenter -t "$container_pid" -n ip -6 addr add "${CONTAINER_IPv6}/128" dev eth0
  local status2=$?

  # Add default route via bridge link-local address
  local status3=0
  if [ -n "$bridge_ll_addr" ]; then
    nsenter -t "$container_pid" -n ip -6 route add default via "$bridge_ll_addr" dev eth0
    status3=$?
  fi

  # Aggregate status: if any failed, report failure
  if [ $status1 -eq 0 ] && [ $status2 -eq 0 ] && [ $status3 -eq 0 ]; then
    eend 0
    return 0
  else
    eend 1
    return 1
  fi
}

stop() {
  ebegin "Stopping ${name}"
  if podman container exists "${CONTAINER_NAME}"; then
    podman stop "${CONTAINER_NAME}"
    eend $?
  else
    einfo "Container ${CONTAINER_NAME} does not exist"
    eend 0
  fi
}

stop_post() {
  # Clean up IPv6 route (ndppd handles NDP proxy cleanup automatically)
  ebegin "Cleaning up IPv6 configuration"
  ip -6 route del "${CONTAINER_IPv6}" dev "${NETWORK_NAME}" 2>/dev/null
  rc=$?
  if [ $rc -eq 0 ] || [ $rc -eq 2 ]; then
    eend 0
  else
    eend $rc
  fi
}

remove() {
  # Remove old container
  ebegin "Removing container ${CONTAINER_NAME}"
  if podman container exists "${CONTAINER_NAME}"; then
    podman rm -f "${CONTAINER_NAME}"
    eend $?
  else
    einfo "Container ${CONTAINER_NAME} does not exist"
    eend 0
  fi
}

status() {
  if podman container exists "${CONTAINER_NAME}"; then
    local state
    state=$(podman inspect "${CONTAINER_NAME}" --format '{{.State.Status}}')
    einfo "Container ${CONTAINER_NAME}: ${state}"
    return 0
  else
    eerror "Container ${CONTAINER_NAME} does not exist"
    return 1
  fi
}
