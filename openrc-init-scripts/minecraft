#!/sbin/openrc-run
# shellcheck shell=bash
# Copyright 2025 Gentoo Authors
# Distributed under the terms of the GNU General Public License v2

# Detect service instance name from symlink (e.g., minecraft.server1 -> server1)
# This allows the same script to manage multiple Minecraft servers via symlinks
RC_SVCNAME="${RC_SVCNAME:-minecraft}"
INSTANCE="${RC_SVCNAME#minecraft}"
INSTANCE="${INSTANCE#.}"  # Remove leading dot if present

# Set dynamic name and description based on instance
if [ -n "${INSTANCE}" ]; then
  # shellcheck disable=SC2034
  name="Minecraft Server (${INSTANCE})"
  # shellcheck disable=SC2034
  description="Minecraft server ${INSTANCE} in Podman container"
else
  # shellcheck disable=SC2034
  name="Minecraft Server"
  # shellcheck disable=SC2034
  description="Minecraft server in Podman container"
fi

# Default configuration values (can be overridden in /etc/conf.d/${RC_SVCNAME})
# When using symlinks, each instance gets its own config file
CONTAINER_NAME="${CONTAINER_NAME:-mc${INSTANCE:+-${INSTANCE}}}"
CONTAINER_IMAGE="${CONTAINER_IMAGE:-ghcr.io/miikkak/mc-server-container:latest}"
CONTAINER_MEMORY="${CONTAINER_MEMORY:-24G}"
CONTAINER_STOP_TIMEOUT="${CONTAINER_STOP_TIMEOUT:-120}"
CONTAINER_MEMORY_JVM_PERCENT="${CONTAINER_MEMORY_JVM_PERCENT:-75}"

NETWORK_NAME="${NETWORK_NAME:-minecraft${INSTANCE:+-${INSTANCE}}-net}"
NETWORK_SUBNET="${NETWORK_SUBNET:-10.10.10.0/24}"
NETWORK_GATEWAY="${NETWORK_GATEWAY:-10.10.10.1}"
CONTAINER_IP="${CONTAINER_IP:-10.10.10.10}"
CONTAINER_IPv6="${CONTAINER_IPv6:-2a01:4f9:3070:1169::b10c:cafe}"
CONTAINER_INTERFACE="${CONTAINER_INTERFACE:-}"

CONTAINER_VOLUMES="${CONTAINER_VOLUMES:-/srv/minecraft${INSTANCE:+/${INSTANCE}}:/data /srv/bluemap${INSTANCE:+/${INSTANCE}}:/data/bluemap}"
CONTAINER_PORTS="${CONTAINER_PORTS:-127.0.0.1:8100:8100 127.0.0.1:9000:9000 127.0.0.1:9940:9940 19132:19132/udp 25565:25565/udp 25565:25565/tcp}"
CONTAINER_ENV="${CONTAINER_ENV:-OTEL_JAVAAGENT_CONFIGURATION_FILE=/data/otel-config.properties}"
CONTAINER_LABELS="${CONTAINER_LABELS:-minecraft.server=true
minecraft.name=${INSTANCE:-default}}"
NETWORK_DISABLE_DNS="${NETWORK_DISABLE_DNS:-true}"

depend() {
  need net
  use podman ndppd
  after firewall
}

# Calculate JVM heap size from container memory limit
# Allocates a percentage of container memory to JVM (default 75%, configurable via CONTAINER_MEMORY_JVM_PERCENT)
# This leaves headroom for JVM metaspace, native memory, and container overhead
# Returns: JVM memory value in G or M units (e.g., "18G" or "512M")
calculate_jvm_memory() {
  local container_mem="$1"
  local jvm_percent="${CONTAINER_MEMORY_JVM_PERCENT}"

  # Extract numeric value and unit (e.g., "24G" -> value=24, unit=G)
  local value unit
  value="${container_mem%[GMKgmk]}"
  unit="${container_mem#"$value"}"

  # Validate input
  if [ -z "$value" ] || [ -z "$unit" ]; then
    eerror "Invalid CONTAINER_MEMORY format: $container_mem (expected format: 24G, 3G, 512M)"
    return 1
  fi

  # Validate numeric value (must be positive integer)
  case "$value" in
    ''|*[!0-9]*|0)
      eerror "Invalid CONTAINER_MEMORY value: $value (must be a positive integer)"
      return 1
      ;;
  esac

  # Convert to MB for calculation
  local mb
  case "$unit" in
    G|g) mb=$((value * 1024)) ;;
    M|m) mb=$value ;;
    K|k) mb=$((value / 1024)) ;;
    *)
      eerror "Unsupported memory unit in CONTAINER_MEMORY: $unit (supported: G, M, K)"
      return 1
      ;;
  esac

  # Calculate JVM memory (apply percentage)
  local jvm_mb=$((mb * jvm_percent / 100))

  # Ensure minimum of 512M
  if [ $jvm_mb -lt 512 ]; then
    ewarn "Calculated JVM memory ${jvm_mb}M is below minimum 512M, using 512M"
    jvm_mb=512
  fi

  # Convert back to appropriate unit (prefer G if >= 1024M, otherwise M)
  if [ $jvm_mb -ge 1024 ]; then
    local jvm_g=$((jvm_mb / 1024))
    echo "${jvm_g}G"
  else
    echo "${jvm_mb}M"
  fi
}

validate_config() {
  local var_name="$1"
  local var_value="$2"
  local pattern="$3"

  # Check for dangerous shell metacharacters
  # Reject: ; & | < > ` $ ( ) { } [ ] " ' \ !
  case "$var_value" in
    *[\;\&\|\<\>\`\$\(\)\{\}\[\]\"\'\\!]*)
      eerror "Invalid characters in ${var_name}: contains shell metacharacters"
      return 1
      ;;
  esac

  # Validate against expected pattern
  if ! echo "$var_value" | grep -Eq "^${pattern}$"; then
    eerror "Invalid format in ${var_name}: does not match expected pattern"
    return 1
  fi

  return 0
}

start_pre() {
  # Validate instance name (if present)
  # Reject service names with trailing dots (e.g., minecraft.) to prevent conflicts with base service
  if [ "${RC_SVCNAME}" != "minecraft" ] && [ -z "${INSTANCE}" ]; then
    eerror "Invalid service name '${RC_SVCNAME}': must be 'minecraft' or 'minecraft.NAME'"
    eerror "Service name cannot have trailing dots"
    return 1
  fi

  if [ -n "${INSTANCE}" ]; then
    # Instance name should only contain lowercase letters, numbers, and hyphens
    # No dots, no leading/trailing hyphens
    if ! echo "${INSTANCE}" | grep -Eq '^[a-z0-9]+(-[a-z0-9]+)*$'; then
      eerror "Invalid instance name '${INSTANCE}': must contain only lowercase letters, numbers, and hyphens"
      eerror "Examples: survival, creative, world-1, lobby-server"
      return 1
    fi
  fi

  # Validate required configuration
  if [ -z "${CONTAINER_NAME}" ] || [ -z "${CONTAINER_IMAGE}" ] || [ -z "${NETWORK_NAME}" ]; then
    eerror "Required configuration variables are not set"
    return 1
  fi

  # Validate configuration variables for security
  # CONTAINER_VOLUMES: paths with optional colon separators and spaces
  if ! validate_config "CONTAINER_VOLUMES" "${CONTAINER_VOLUMES}" "[a-zA-Z0-9/_. :-]*"; then
    return 1
  fi

  # CONTAINER_PORTS: IP addresses, ports, protocols (tcp/udp) with spaces
  if ! validate_config "CONTAINER_PORTS" "${CONTAINER_PORTS}" "[0-9a-zA-Z.:/ -]*"; then
    return 1
  fi

  # CONTAINER_ENV: KEY=value pairs with newlines (multiline values supported)
  # Validate by removing newlines first, then checking allowed characters
  # This is safe because: spaces are already allowed in the pattern, so replacing
  # newlines with spaces doesn't change validation semantics (e.g., "KEY1=val1\nKEY2=val2"
  # becomes "KEY1=val1 KEY2=val2" which is valid since both spaces and = are allowed)
  local env_cleaned="${CONTAINER_ENV//$'\n'/ }"
  if ! validate_config "CONTAINER_ENV" "${env_cleaned}" "[a-zA-Z0-9_=/.@:+ -]*"; then
    return 1
  fi

  # CONTAINER_LABELS: key=value pairs with newlines (multiline values supported)
  # Validate by removing newlines first, then checking allowed characters
  # Same reasoning as CONTAINER_ENV: spaces are allowed, so newlineâ†’space is safe
  local labels_cleaned="${CONTAINER_LABELS//$'\n'/ }"
  if ! validate_config "CONTAINER_LABELS" "${labels_cleaned}" "[a-zA-Z0-9_.=: -]*"; then
    return 1
  fi

  # Calculate JVM memory from container memory limit if MEMORY not already set in CONTAINER_ENV
  # This ensures JVM heap size is appropriate for the container's memory limit
  # Check for MEMORY= at start of line (handles both single-line and multi-line CONTAINER_ENV)
  if ! echo "${CONTAINER_ENV}" | grep -qE '(^|[[:space:]])MEMORY='; then
    local calculated_memory
    if calculated_memory=$(calculate_jvm_memory "${CONTAINER_MEMORY}") && [ -n "${calculated_memory}" ]; then
      # Add MEMORY to CONTAINER_ENV
      if [ -z "${CONTAINER_ENV}" ]; then
        CONTAINER_ENV="MEMORY=${calculated_memory}"
      else
        CONTAINER_ENV="${CONTAINER_ENV}
MEMORY=${calculated_memory}"
      fi
      einfo "Auto-calculated JVM memory: ${calculated_memory} (${CONTAINER_MEMORY_JVM_PERCENT}% of ${CONTAINER_MEMORY} container limit)"
    else
      ewarn "Failed to calculate JVM memory, container will use entrypoint default (16G)"
    fi
  else
    einfo "MEMORY already configured in CONTAINER_ENV, skipping auto-calculation"
  fi

  # Check for IP conflicts on the same network (excluding this container)
  if podman network exists "${NETWORK_NAME}" >/dev/null 2>&1; then
    # Extract subnet mask from NETWORK_SUBNET (e.g., "10.10.10.0/24" -> "24")
    local subnet_mask="${NETWORK_SUBNET##*/}"

    # Build target IP with subnet mask for podman template matching
    # Note: Shell expands variables before podman sees the Go template
    local target_ip="${CONTAINER_IP}/${subnet_mask}"

    # Find which container (if any) is using this IP address
    local ip_owner
    ip_owner=$(podman network inspect "${NETWORK_NAME}" --format '{{range .Containers}}{{if eq .IPv4Address "'"${target_ip}"'"}}{{.Name}}{{end}}{{end}}' 2>/dev/null)
    if [ -n "${ip_owner}" ] && [ "${ip_owner}" != "${CONTAINER_NAME}" ]; then
      ewarn "IP address ${CONTAINER_IP} is already in use by container '${ip_owner}' on network ${NETWORK_NAME}"
      ewarn "Please assign a unique IP address to avoid conflicts"
    fi
  fi

  # Ensure network exists
  if ! podman network exists "${NETWORK_NAME}" >/dev/null 2>&1; then
    ebegin "Creating Podman network ${NETWORK_NAME}"
    local network_args=(
      --subnet "${NETWORK_SUBNET}"
      --gateway "${NETWORK_GATEWAY}"
    )

    # Only set interface name if it's 15 characters or less (IFNAMSIZ kernel limit: 16 bytes including null terminator)
    # Otherwise, let Podman auto-generate an interface name
    if [ ${#NETWORK_NAME} -le 15 ]; then
      network_args+=(--interface-name "${NETWORK_NAME}")
    fi

    if [ "${NETWORK_DISABLE_DNS}" = "true" ]; then
      network_args+=(--disable-dns)
    fi

    if ! podman network create "${network_args[@]}" "${NETWORK_NAME}" >/dev/null; then
      eend 1
      eerror "Failed to create Podman network ${NETWORK_NAME}"
      eerror "This usually means the subnet ${NETWORK_SUBNET} is already in use."
      eerror ""
      eerror "To diagnose:"
      eerror "  podman network ls"
      eerror "  podman network inspect <network-name>"
      eerror ""
      eerror "To clean up unused networks from previous instances:"
      eerror "  rc-service ${RC_SVCNAME} remove_network"
      return 1
    fi
    eend 0
  fi
}

start() {
  local ret=1
  ebegin "Starting ${name}"

  # Check if container already exists
  if podman container exists "${CONTAINER_NAME}"; then
    # Container exists, just start it
    podman start "${CONTAINER_NAME}" >/dev/null
    ret=$?
  else
    # Build volume arguments
    local volume_args=()
    for vol in ${CONTAINER_VOLUMES}; do
      volume_args+=("-v" "${vol}")
    done

    # Build port arguments
    local port_args=()
    for port in ${CONTAINER_PORTS}; do
      port_args+=("-p" "${port}")
    done

    # Build environment arguments
    local env_args=()
    local env_array=()
    mapfile -t env_array <<< "${CONTAINER_ENV}"
    for env in "${env_array[@]}"; do
      # Skip empty lines
      [ -z "${env}" ] && continue
      env_args+=("-e" "${env}")
    done

    # Build label arguments
    local label_args=()
    local label_array=()
    mapfile -t label_array <<< "${CONTAINER_LABELS}"
    for label in "${label_array[@]}"; do
      # Skip empty lines
      [ -z "${label}" ] && continue
      label_args+=("--label" "${label}")
    done

    # Create and start new container
    podman run -d \
      --name "${CONTAINER_NAME}" \
      --memory "${CONTAINER_MEMORY}" \
      --network "${NETWORK_NAME}" \
      --ip "${CONTAINER_IP}" \
      --stop-timeout "${CONTAINER_STOP_TIMEOUT}" \
      "${volume_args[@]}" \
      "${port_args[@]}" \
      "${env_args[@]}" \
      "${label_args[@]}" \
      "${CONTAINER_IMAGE}" >/dev/null
    ret=$?
  fi

  if [ $ret -eq 0 ]; then
    # Wait for container to be running (with timeout)
    if timeout 30 podman wait --condition=running "${CONTAINER_NAME}" >/dev/null; then
      # Setup IPv6 if CONTAINER_IPv6 is set
      if [ -n "${CONTAINER_IPv6}" ]; then
        setup_ipv6
        local ipv6_ret=$?
        if [ $ipv6_ret -ne 0 ]; then
          ewarn "IPv6 setup failed (code $ipv6_ret), continuing without IPv6."
        else
          # Store IPv6 info in state file for cleanup on config change
          # Get bridge interface name for cleanup
          local cleanup_bridge
          cleanup_bridge=$(podman network inspect "${NETWORK_NAME}" --format '{{.NetworkInterface}}' 2>/dev/null)
          # Only write state file if we have both IPv6 and bridge interface
          if [ -n "${cleanup_bridge}" ]; then
            echo "${CONTAINER_IPv6} ${cleanup_bridge}" > "/var/run/openrc/${RC_SVCNAME}-ipv6" 2>/dev/null || true
          fi
        fi
      else
        einfo "IPv6 address not set, skipping IPv6 configuration"
      fi
    else
      ewarn "Container did not reach running state within 30 seconds"
      ret=1
    fi
  fi
  eend $ret
}

setup_ipv6() {
  local container_pid bridge_ll_addr container_iface
  container_pid=$(podman inspect "${CONTAINER_NAME}" --format '{{.State.Pid}}')

  # Validate container_pid is a positive integer using POSIX-compliant case statement
  case "$container_pid" in
    ''|*[!0-9]*|0)
      ewarn "Could not get container PID for IPv6 setup"
      return 1
      ;;
  esac

  # Determine container interface name
  if [ -n "${CONTAINER_INTERFACE}" ]; then
    # Use explicitly configured interface
    container_iface="${CONTAINER_INTERFACE}"
  else
    # Detect the first non-loopback, non-tunnel interface dynamically
    # Filter out tunnel interfaces: sit*, ip6tnl*, ip6_vti*, ip_vti*, gre*, ipip*, tunl*
    # Strip @... suffixes (e.g., sit0@NONE -> sit0)
    container_iface=$(nsenter -t "$container_pid" -n ip -o link show | awk '
      $2 != "lo:" {
        gsub(/:$/, "", $2)
        gsub(/@.*$/, "", $2)
        if ($2 !~ /^(sit|ip6tnl|ip6_vti|ip_vti|gre|ipip|tunl)[0-9]*$/) {
          print $2
          exit
        }
      }
    ')
    if [ -z "$container_iface" ]; then
      ewarn "Could not detect container network interface"
      return 1
    fi
  fi

  # Get actual bridge interface name from Podman network
  local bridge_iface
  bridge_iface=$(podman network inspect "${NETWORK_NAME}" --format '{{.NetworkInterface}}' 2>/dev/null)
  if [ -z "$bridge_iface" ]; then
    ewarn "Could not determine bridge interface for network ${NETWORK_NAME}"
    return 1
  fi

  # Add route to container (ndppd handles NDP proxy)
  if ! ip -6 route replace "${CONTAINER_IPv6}" dev "${bridge_iface}" 2>/dev/null; then
    ewarn "Failed to add IPv6 route for ${CONTAINER_IPv6}"
    return 1
  fi

  # Get bridge link-local address
  bridge_ll_addr=$(ip -6 addr show dev "${bridge_iface}" scope link | awk '/inet6 fe80/ {split($2, a, "/"); print a[1]; exit}')

  # Configure container IPv6 as /128
  if ! nsenter -t "$container_pid" -n ip -6 addr replace "${CONTAINER_IPv6}/128" dev "$container_iface" 2>/dev/null; then
    ewarn "Failed to configure container IPv6 address"
    return 1
  fi

  # Add default route via bridge link-local address
  if [ -n "$bridge_ll_addr" ]; then
    if ! nsenter -t "$container_pid" -n ip -6 route replace default via "$bridge_ll_addr" dev "$container_iface" 2>/dev/null; then
      ewarn "Failed to add default IPv6 route"
      return 1
    fi
  fi

  return 0
}

stop() {
  ebegin "Stopping ${name}"
  if podman container exists "${CONTAINER_NAME}"; then
    podman stop "${CONTAINER_NAME}" >/dev/null
    eend $?
  else
    einfo "Container ${CONTAINER_NAME} does not exist"
    eend 0
  fi
}

stop_post() {
  # Clean up IPv6 route (ndppd handles NDP proxy cleanup automatically)
  # Check both current config and state file to handle config changes
  local ipv6_to_cleanup="${CONTAINER_IPv6}"
  local bridge_to_cleanup

  # Try to get current bridge interface
  if [ -n "${ipv6_to_cleanup}" ]; then
    bridge_to_cleanup=$(podman network inspect "${NETWORK_NAME}" --format '{{.NetworkInterface}}' 2>/dev/null)
  fi

  # If current config has no IPv6, check state file for previously configured address
  if [ -z "${ipv6_to_cleanup}" ] && [ -f "/var/run/openrc/${RC_SVCNAME}-ipv6" ]; then
    local state_info
    state_info=$(cat "/var/run/openrc/${RC_SVCNAME}-ipv6" 2>/dev/null)
    # State file format: "IPv6_ADDR BRIDGE_IFACE"
    ipv6_to_cleanup=$(echo "$state_info" | awk '{print $1}')
    bridge_to_cleanup=$(echo "$state_info" | awk '{print $2}')
  fi

  # Clean up if we have an IPv6 address to clean
  if [ -n "${ipv6_to_cleanup}" ] && [ -n "${bridge_to_cleanup}" ]; then
    # Check if bridge interface still exists before attempting cleanup
    if ip link show "${bridge_to_cleanup}" >/dev/null 2>&1; then
      # Best-effort cleanup: delete route if it exists silently
      # Don't fail the stop operation if cleanup fails
      ip -6 route del "${ipv6_to_cleanup}" dev "${bridge_to_cleanup}" 2>/dev/null
    fi

    # Remove state file after cleanup (or attempted cleanup)
    rm -f "/var/run/openrc/${RC_SVCNAME}-ipv6" 2>/dev/null
  fi
}

remove() {
  # Remove old container
  ebegin "Removing container ${CONTAINER_NAME}"
  if podman container exists "${CONTAINER_NAME}"; then
    podman rm -f "${CONTAINER_NAME}" >/dev/null
    eend $?
  else
    einfo "Container ${CONTAINER_NAME} does not exist"
    eend 0
  fi
}

status() {
  if podman container exists "${CONTAINER_NAME}"; then
    local state
    state=$(podman inspect "${CONTAINER_NAME}" --format '{{.State.Status}}')
    einfo "Container ${CONTAINER_NAME}: ${state}"
    return 0
  else
    eerror "Container ${CONTAINER_NAME} does not exist"
    return 1
  fi
}

remove_network() {
  # Remove network (checks if it's safe to remove)
  ebegin "Removing network ${NETWORK_NAME}"

  if ! podman network exists "${NETWORK_NAME}" >/dev/null 2>&1; then
    einfo "Network ${NETWORK_NAME} does not exist"
    eend 0
    return 0
  fi

  # Check if any containers are using this network
  local containers_using_network
  containers_using_network=$(podman network inspect "${NETWORK_NAME}" --format '{{len .Containers}}' 2>/dev/null)

  # Validate we got a numeric value and check if > 0
  # Use case statement for POSIX-compliant integer validation
  case "${containers_using_network}" in
    ''|*[!0-9]*)
      # Empty or non-numeric - skip check and try removal (will fail if in use)
      ;;
    *)
      # Valid number - check if network is in use
      if [ "${containers_using_network}" -gt 0 ]; then
        eend 1
        eerror "Network ${NETWORK_NAME} is still in use by ${containers_using_network} container(s)"
        eerror "Stop and remove all containers first:"
        eerror "  rc-service ${RC_SVCNAME} stop"
        eerror "  rc-service ${RC_SVCNAME} remove"
        return 1
      fi
      ;;
  esac

  podman network rm "${NETWORK_NAME}" >/dev/null
  eend $?
}

extra_commands="remove remove_network"
extra_started_commands=""
